{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { array, isArray, isObject, isString } from 'vega-util';\nimport { isBinned } from '../../../bin';\nimport { getMainRangeChannel, isXorY, THETA, RADIUS } from '../../../channel';\nimport { defaultTitle, getFieldDef, getFormatMixins, hasConditionalFieldDef, isFieldDef, isTypedFieldDef, vgField } from '../../../channeldef';\nimport { forEach } from '../../../encoding';\nimport { entries } from '../../../util';\nimport { isSignalRef } from '../../../vega.schema';\nimport { getMarkPropOrConfig } from '../../common';\nimport { binFormatExpression, formatSignalRef } from '../../format';\nimport { wrapCondition } from './conditional';\nimport { textRef } from './text';\nexport function tooltip(model, opt = {}) {\n  const {\n    encoding,\n    markDef,\n    config,\n    stack\n  } = model;\n  const channelDef = encoding.tooltip;\n  if (isArray(channelDef)) {\n    return {\n      tooltip: tooltipRefForEncoding({\n        tooltip: channelDef\n      }, stack, config, opt)\n    };\n  } else {\n    const datum = opt.reactiveGeom ? 'datum.datum' : 'datum';\n    return wrapCondition(model, channelDef, 'tooltip', cDef => {\n      // use valueRef based on channelDef first\n      const tooltipRefFromChannelDef = textRef(cDef, config, datum);\n      if (tooltipRefFromChannelDef) {\n        return tooltipRefFromChannelDef;\n      }\n      if (cDef === null) {\n        // Allow using encoding.tooltip = null to disable tooltip\n        return undefined;\n      }\n      let markTooltip = getMarkPropOrConfig('tooltip', markDef, config);\n      if (markTooltip === true) {\n        markTooltip = {\n          content: 'encoding'\n        };\n      }\n      if (isString(markTooltip)) {\n        return {\n          value: markTooltip\n        };\n      } else if (isObject(markTooltip)) {\n        // `tooltip` is `{fields: 'encodings' | 'fields'}`\n        if (isSignalRef(markTooltip)) {\n          return markTooltip;\n        } else if (markTooltip.content === 'encoding') {\n          return tooltipRefForEncoding(encoding, stack, config, opt);\n        } else {\n          return {\n            signal: datum\n          };\n        }\n      }\n      return undefined;\n    });\n  }\n}\nexport function tooltipData(encoding, stack, config, {\n  reactiveGeom\n} = {}) {\n  const toSkip = {};\n  const expr = reactiveGeom ? 'datum.datum' : 'datum';\n  const tuples = [];\n  function add(fDef, channel) {\n    const mainChannel = getMainRangeChannel(channel);\n    const fieldDef = isTypedFieldDef(fDef) ? fDef : {\n      ...fDef,\n      type: encoding[mainChannel].type // for secondary field def, copy type from main channel\n    };\n\n    const title = fieldDef.title || defaultTitle(fieldDef, config);\n    const key = array(title).join(', ');\n    let value;\n    if (isXorY(channel)) {\n      const channel2 = channel === 'x' ? 'x2' : 'y2';\n      const fieldDef2 = getFieldDef(encoding[channel2]);\n      if (isBinned(fieldDef.bin) && fieldDef2) {\n        const startField = vgField(fieldDef, {\n          expr\n        });\n        const endField = vgField(fieldDef2, {\n          expr\n        });\n        const {\n          format,\n          formatType\n        } = getFormatMixins(fieldDef);\n        value = binFormatExpression(startField, endField, format, formatType, config);\n        toSkip[channel2] = true;\n      }\n    }\n    if ((isXorY(channel) || channel === THETA || channel === RADIUS) && stack && stack.fieldChannel === channel && stack.offset === 'normalize') {\n      const {\n        format,\n        formatType\n      } = getFormatMixins(fieldDef);\n      value = formatSignalRef({\n        fieldOrDatumDef: fieldDef,\n        format,\n        formatType,\n        expr,\n        config,\n        normalizeStack: true\n      }).signal;\n    }\n    value ?? (value = textRef(fieldDef, config, expr).signal);\n    tuples.push({\n      channel,\n      key,\n      value\n    });\n  }\n  forEach(encoding, (channelDef, channel) => {\n    if (isFieldDef(channelDef)) {\n      add(channelDef, channel);\n    } else if (hasConditionalFieldDef(channelDef)) {\n      add(channelDef.condition, channel);\n    }\n  });\n  const out = {};\n  for (const {\n    channel,\n    key,\n    value\n  } of tuples) {\n    if (!toSkip[channel] && !out[key]) {\n      out[key] = value;\n    }\n  }\n  return out;\n}\nexport function tooltipRefForEncoding(encoding, stack, config, {\n  reactiveGeom\n} = {}) {\n  const data = tooltipData(encoding, stack, config, {\n    reactiveGeom\n  });\n  const keyValues = entries(data).map(([key, value]) => `\"${key}\": ${value}`);\n  return keyValues.length > 0 ? {\n    signal: `{${keyValues.join(', ')}}`\n  } : undefined;\n}","map":{"version":3,"mappings":"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","names":["array","isArray","isObject","isString","isBinned","getMainRangeChannel","isXorY","THETA","RADIUS","defaultTitle","getFieldDef","getFormatMixins","hasConditionalFieldDef","isFieldDef","isTypedFieldDef","vgField","forEach","entries","isSignalRef","getMarkPropOrConfig","binFormatExpression","formatSignalRef","wrapCondition","textRef","tooltip","model","opt","encoding","markDef","config","stack","channelDef","tooltipRefForEncoding","datum","reactiveGeom","cDef","tooltipRefFromChannelDef","undefined","markTooltip","content","value","signal","tooltipData","toSkip","expr","tuples","add","fDef","channel","mainChannel","fieldDef","type","title","key","join","channel2","fieldDef2","bin","startField","endField","format","formatType","fieldChannel","offset","fieldOrDatumDef","normalizeStack","push","condition","out","data","keyValues","map","length"],"sourceRoot":"","sources":["../../../../../src/compile/mark/encode/tooltip.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module","externalDependencies":[]}