{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { array, isBoolean } from 'vega-util';\nimport { SUM_OPS } from './aggregate';\nimport { getSecondaryRangeChannel, NONPOSITION_CHANNELS } from './channel';\nimport { channelDefType, getFieldDef, isFieldDef, isFieldOrDatumDef, vgField } from './channeldef';\nimport { channelHasField, isAggregate } from './encoding';\nimport * as log from './log';\nimport { ARC, AREA, BAR, CIRCLE, isMarkDef, isPathMark, LINE, POINT, RULE, SQUARE, TEXT, TICK } from './mark';\nimport { ScaleType } from './scale';\nconst STACK_OFFSET_INDEX = {\n  zero: 1,\n  center: 1,\n  normalize: 1\n};\nexport function isStackOffset(s) {\n  return s in STACK_OFFSET_INDEX;\n}\nexport const STACKABLE_MARKS = new Set([ARC, BAR, AREA, RULE, POINT, CIRCLE, SQUARE, LINE, TEXT, TICK]);\nexport const STACK_BY_DEFAULT_MARKS = new Set([BAR, AREA, ARC]);\nfunction isUnbinnedQuantitative(channelDef) {\n  return isFieldDef(channelDef) && channelDefType(channelDef) === 'quantitative' && !channelDef.bin;\n}\nfunction potentialStackedChannel(encoding, x, {\n  orient,\n  type: mark\n}) {\n  const y = x === 'x' ? 'y' : 'radius';\n  const isCartesian = x === 'x';\n  const xDef = encoding[x];\n  const yDef = encoding[y];\n  if (isFieldDef(xDef) && isFieldDef(yDef)) {\n    if (isUnbinnedQuantitative(xDef) && isUnbinnedQuantitative(yDef)) {\n      if (xDef.stack) {\n        return x;\n      } else if (yDef.stack) {\n        return y;\n      }\n      const xAggregate = isFieldDef(xDef) && !!xDef.aggregate;\n      const yAggregate = isFieldDef(yDef) && !!yDef.aggregate;\n      // if there is no explicit stacking, only apply stack if there is only one aggregate for x or y\n      if (xAggregate !== yAggregate) {\n        return xAggregate ? x : y;\n      }\n      if (isCartesian && mark === 'bar') {\n        if (orient === 'vertical') {\n          return y;\n        } else if (orient === 'horizontal') {\n          return x;\n        }\n      }\n    } else if (isUnbinnedQuantitative(xDef)) {\n      return x;\n    } else if (isUnbinnedQuantitative(yDef)) {\n      return y;\n    }\n  } else if (isUnbinnedQuantitative(xDef)) {\n    return x;\n  } else if (isUnbinnedQuantitative(yDef)) {\n    return y;\n  }\n  return undefined;\n}\nfunction getDimensionChannel(channel) {\n  switch (channel) {\n    case 'x':\n      return 'y';\n    case 'y':\n      return 'x';\n    case 'theta':\n      return 'radius';\n    case 'radius':\n      return 'theta';\n  }\n}\nexport function stack(m, encoding) {\n  const markDef = isMarkDef(m) ? m : {\n    type: m\n  };\n  const mark = markDef.type;\n  // Should have stackable mark\n  if (!STACKABLE_MARKS.has(mark)) {\n    return null;\n  }\n  // Run potential stacked twice, one for Cartesian and another for Polar,\n  // so text marks can be stacked in any of the coordinates.\n  // Note: The logic here is not perfectly correct.  If we want to support stacked dot plots where each dot is a pie chart with label, we have to change the stack logic here to separate Cartesian stacking for polar stacking.\n  // However, since we probably never want to do that, let's just note the limitation here.\n  const fieldChannel = potentialStackedChannel(encoding, 'x', markDef) || potentialStackedChannel(encoding, 'theta', markDef);\n  if (!fieldChannel) {\n    return null;\n  }\n  const stackedFieldDef = encoding[fieldChannel];\n  const stackedField = isFieldDef(stackedFieldDef) ? vgField(stackedFieldDef, {}) : undefined;\n  const dimensionChannel = getDimensionChannel(fieldChannel);\n  const groupbyChannels = [];\n  const groupbyFields = new Set();\n  if (encoding[dimensionChannel]) {\n    const dimensionDef = encoding[dimensionChannel];\n    const dimensionField = isFieldDef(dimensionDef) ? vgField(dimensionDef, {}) : undefined;\n    if (dimensionField && dimensionField !== stackedField) {\n      // avoid grouping by the stacked field\n      groupbyChannels.push(dimensionChannel);\n      groupbyFields.add(dimensionField);\n    }\n    const dimensionOffsetChannel = dimensionChannel === 'x' ? 'xOffset' : 'yOffset';\n    const dimensionOffsetDef = encoding[dimensionOffsetChannel];\n    const dimensionOffsetField = isFieldDef(dimensionOffsetDef) ? vgField(dimensionOffsetDef, {}) : undefined;\n    if (dimensionOffsetField && dimensionOffsetField !== stackedField) {\n      // avoid grouping by the stacked field\n      groupbyChannels.push(dimensionOffsetChannel);\n      groupbyFields.add(dimensionOffsetField);\n    }\n  }\n  // If the dimension has offset, don't stack anymore\n  // Should have grouping level of detail that is different from the dimension field\n  const stackBy = NONPOSITION_CHANNELS.reduce((sc, channel) => {\n    // Ignore tooltip in stackBy (https://github.com/vega/vega-lite/issues/4001)\n    if (channel !== 'tooltip' && channelHasField(encoding, channel)) {\n      const channelDef = encoding[channel];\n      for (const cDef of array(channelDef)) {\n        const fieldDef = getFieldDef(cDef);\n        if (fieldDef.aggregate) {\n          continue;\n        }\n        // Check whether the channel's field is identical to x/y's field or if the channel is a repeat\n        const f = vgField(fieldDef, {});\n        if (\n        // if fielddef is a repeat, just include it in the stack by\n        !f ||\n        // otherwise, the field must be different from the groupBy fields.\n        !groupbyFields.has(f)) {\n          sc.push({\n            channel,\n            fieldDef\n          });\n        }\n      }\n    }\n    return sc;\n  }, []);\n  // Automatically determine offset\n  let offset;\n  if (stackedFieldDef.stack !== undefined) {\n    if (isBoolean(stackedFieldDef.stack)) {\n      offset = stackedFieldDef.stack ? 'zero' : null;\n    } else {\n      offset = stackedFieldDef.stack;\n    }\n  } else if (STACK_BY_DEFAULT_MARKS.has(mark)) {\n    offset = 'zero';\n  }\n  if (!offset || !isStackOffset(offset)) {\n    return null;\n  }\n  if (isAggregate(encoding) && stackBy.length === 0) {\n    return null;\n  }\n  // warn when stacking non-linear\n  if (stackedFieldDef?.scale?.type && stackedFieldDef?.scale?.type !== ScaleType.LINEAR) {\n    if (stackedFieldDef?.stack) {\n      log.warn(log.message.cannotStackNonLinearScale(stackedFieldDef.scale.type));\n    }\n    return null;\n  }\n  // Check if it is a ranged mark\n  if (isFieldOrDatumDef(encoding[getSecondaryRangeChannel(fieldChannel)])) {\n    if (stackedFieldDef.stack !== undefined) {\n      log.warn(log.message.cannotStackRangedMark(fieldChannel));\n    }\n    return null;\n  }\n  // Warn if stacking non-summative aggregate\n  if (isFieldDef(stackedFieldDef) && stackedFieldDef.aggregate && !SUM_OPS.has(stackedFieldDef.aggregate)) {\n    log.warn(log.message.stackNonSummativeAggregate(stackedFieldDef.aggregate));\n  }\n  return {\n    groupbyChannels,\n    groupbyFields,\n    fieldChannel,\n    impute: stackedFieldDef.impute === null ? false : isPathMark(mark),\n    stackBy,\n    offset\n  };\n}","map":{"version":3,"mappings":"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","names":["array","isBoolean","SUM_OPS","getSecondaryRangeChannel","NONPOSITION_CHANNELS","channelDefType","getFieldDef","isFieldDef","isFieldOrDatumDef","vgField","channelHasField","isAggregate","log","ARC","AREA","BAR","CIRCLE","isMarkDef","isPathMark","LINE","POINT","RULE","SQUARE","TEXT","TICK","ScaleType","STACK_OFFSET_INDEX","zero","center","normalize","isStackOffset","s","STACKABLE_MARKS","Set","STACK_BY_DEFAULT_MARKS","isUnbinnedQuantitative","channelDef","bin","potentialStackedChannel","encoding","x","orient","type","mark","y","isCartesian","xDef","yDef","stack","xAggregate","aggregate","yAggregate","undefined","getDimensionChannel","channel","m","markDef","has","fieldChannel","stackedFieldDef","stackedField","dimensionChannel","groupbyChannels","groupbyFields","dimensionDef","dimensionField","push","add","dimensionOffsetChannel","dimensionOffsetDef","dimensionOffsetField","stackBy","reduce","sc","cDef","fieldDef","f","offset","length","scale","LINEAR","warn","message","cannotStackNonLinearScale","cannotStackRangedMark","stackNonSummativeAggregate","impute"],"sourceRoot":"","sources":["../../src/stack.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module","externalDependencies":[]}