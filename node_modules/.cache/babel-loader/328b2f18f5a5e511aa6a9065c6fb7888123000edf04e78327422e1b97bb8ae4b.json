{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { array, isArray } from 'vega-util';\nimport { AXIS_PARTS, AXIS_PROPERTY_TYPE, CONDITIONAL_AXIS_PROP_INDEX, isConditionalAxisValue } from '../../axis';\nimport { POSITION_SCALE_CHANNELS } from '../../channel';\nimport { defaultTitle } from '../../channeldef';\nimport { isText } from '../../title';\nimport { contains, getFirstDefined, isEmpty, replaceAll } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { exprFromValueRefOrSignalRef } from '../common';\nimport { expression } from '../predicate';\nfunction assembleTitle(title, config) {\n  if (!title) {\n    return undefined;\n  }\n  if (isArray(title) && !isText(title)) {\n    return title.map(fieldDef => defaultTitle(fieldDef, config)).join(', ');\n  }\n  return title;\n}\nfunction setAxisEncode(axis, part, vgProp, vgRef) {\n  var _a, _b;\n  axis.encode ?? (axis.encode = {});\n  (_a = axis.encode)[part] ?? (_a[part] = {});\n  (_b = axis.encode[part]).update ?? (_b.update = {});\n  // TODO: remove as any after https://github.com/prisma/nexus-prisma/issues/291\n  axis.encode[part].update[vgProp] = vgRef;\n}\nexport function assembleAxis(axisCmpt, kind, config, opt = {\n  header: false\n}) {\n  const {\n    disable,\n    orient,\n    scale,\n    labelExpr,\n    title,\n    zindex,\n    ...axis\n  } = axisCmpt.combine();\n  if (disable) {\n    return undefined;\n  }\n  for (const prop in axis) {\n    const propType = AXIS_PROPERTY_TYPE[prop];\n    const propValue = axis[prop];\n    if (propType && propType !== kind && propType !== 'both') {\n      // Remove properties that are not valid for this kind of axis\n      delete axis[prop];\n    } else if (isConditionalAxisValue(propValue)) {\n      // deal with conditional axis value\n      const {\n        condition,\n        ...valueOrSignalRef\n      } = propValue;\n      const conditions = array(condition);\n      const propIndex = CONDITIONAL_AXIS_PROP_INDEX[prop];\n      if (propIndex) {\n        const {\n          vgProp,\n          part\n        } = propIndex;\n        // If there is a corresponding Vega property for the channel,\n        // use Vega's custom axis encoding and delete the original axis property to avoid conflicts\n        const vgRef = [...conditions.map(c => {\n          const {\n            test,\n            ...valueOrSignalCRef\n          } = c;\n          return {\n            test: expression(null, test),\n            ...valueOrSignalCRef\n          };\n        }), valueOrSignalRef];\n        setAxisEncode(axis, part, vgProp, vgRef);\n        delete axis[prop];\n      } else if (propIndex === null) {\n        // If propIndex is null, this means we support conditional axis property by converting the condition to signal instead.\n        const signalRef = {\n          signal: conditions.map(c => {\n            const {\n              test,\n              ...valueOrSignalCRef\n            } = c;\n            return `${expression(null, test)} ? ${exprFromValueRefOrSignalRef(valueOrSignalCRef)} : `;\n          }).join('') + exprFromValueRefOrSignalRef(valueOrSignalRef)\n        };\n        axis[prop] = signalRef;\n      }\n    } else if (isSignalRef(propValue)) {\n      const propIndex = CONDITIONAL_AXIS_PROP_INDEX[prop];\n      if (propIndex) {\n        const {\n          vgProp,\n          part\n        } = propIndex;\n        setAxisEncode(axis, part, vgProp, propValue);\n        delete axis[prop];\n      } // else do nothing since the property already supports signal\n    }\n    // Do not pass labelAlign/Baseline = null to Vega since it won't pass the schema\n    // Note that we need to use null so the default labelAlign is preserved.\n    if (contains(['labelAlign', 'labelBaseline'], prop) && axis[prop] === null) {\n      delete axis[prop];\n    }\n  }\n  if (kind === 'grid') {\n    if (!axis.grid) {\n      return undefined;\n    }\n    // Remove unnecessary encode block\n    if (axis.encode) {\n      // Only need to keep encode block for grid\n      const {\n        grid\n      } = axis.encode;\n      axis.encode = {\n        ...(grid ? {\n          grid\n        } : {})\n      };\n      if (isEmpty(axis.encode)) {\n        delete axis.encode;\n      }\n    }\n    return {\n      scale,\n      orient,\n      ...axis,\n      domain: false,\n      labels: false,\n      aria: false,\n      // Always set min/maxExtent to 0 to ensure that `config.axis*.minExtent` and `config.axis*.maxExtent`\n      // would not affect gridAxis\n      maxExtent: 0,\n      minExtent: 0,\n      ticks: false,\n      zindex: getFirstDefined(zindex, 0) // put grid behind marks by default\n    };\n  } else {\n    // kind === 'main'\n    if (!opt.header && axisCmpt.mainExtracted) {\n      // if mainExtracted has been extracted to a separate facet\n      return undefined;\n    }\n    if (labelExpr !== undefined) {\n      let expr = labelExpr;\n      if (axis.encode?.labels?.update && isSignalRef(axis.encode.labels.update.text)) {\n        expr = replaceAll(labelExpr, 'datum.label', axis.encode.labels.update.text.signal);\n      }\n      setAxisEncode(axis, 'labels', 'text', {\n        signal: expr\n      });\n    }\n    if (axis.labelAlign === null) {\n      delete axis.labelAlign;\n    }\n    // Remove unnecessary encode block\n    if (axis.encode) {\n      for (const part of AXIS_PARTS) {\n        if (!axisCmpt.hasAxisPart(part)) {\n          delete axis.encode[part];\n        }\n      }\n      if (isEmpty(axis.encode)) {\n        delete axis.encode;\n      }\n    }\n    const titleString = assembleTitle(title, config);\n    return {\n      scale,\n      orient,\n      grid: false,\n      ...(titleString ? {\n        title: titleString\n      } : {}),\n      ...axis,\n      ...(config.aria === false ? {\n        aria: false\n      } : {}),\n      zindex: getFirstDefined(zindex, 0) // put axis line above marks by default\n    };\n  }\n}\n/**\r\n * Add axis signals so grid line works correctly\r\n * (Fix https://github.com/vega/vega-lite/issues/4226)\r\n */\nexport function assembleAxisSignals(model) {\n  const {\n    axes\n  } = model.component;\n  const signals = [];\n  for (const channel of POSITION_SCALE_CHANNELS) {\n    if (axes[channel]) {\n      for (const axis of axes[channel]) {\n        if (!axis.get('disable') && !axis.get('gridScale')) {\n          // If there is x-axis but no y-scale for gridScale, need to set height/width so x-axis can draw the grid with the right height. Same for y-axis and width.\n          const sizeType = channel === 'x' ? 'height' : 'width';\n          const update = model.getSizeSignalRef(sizeType).signal;\n          if (sizeType !== update) {\n            signals.push({\n              name: sizeType,\n              update\n            });\n          }\n        }\n      }\n    }\n  }\n  return signals;\n}\nexport function assembleAxes(axisComponents, config) {\n  const {\n    x = [],\n    y = []\n  } = axisComponents;\n  return [...x.map(a => assembleAxis(a, 'grid', config)), ...y.map(a => assembleAxis(a, 'grid', config)), ...x.map(a => assembleAxis(a, 'main', config)), ...y.map(a => assembleAxis(a, 'main', config))].filter(a => a); // filter undefined\n}","map":{"version":3,"mappings":"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","names":["array","isArray","AXIS_PARTS","AXIS_PROPERTY_TYPE","CONDITIONAL_AXIS_PROP_INDEX","isConditionalAxisValue","POSITION_SCALE_CHANNELS","defaultTitle","isText","contains","getFirstDefined","isEmpty","replaceAll","isSignalRef","exprFromValueRefOrSignalRef","expression","assembleTitle","title","config","undefined","map","fieldDef","join","setAxisEncode","axis","part","vgProp","vgRef","encode","update","assembleAxis","axisCmpt","kind","opt","header","disable","orient","scale","labelExpr","zindex","combine","prop","propType","propValue","condition","valueOrSignalRef","conditions","propIndex","c","test","valueOrSignalCRef","signalRef","signal","grid","domain","labels","aria","maxExtent","minExtent","ticks","mainExtracted","expr","text","labelAlign","hasAxisPart","titleString","assembleAxisSignals","model","axes","component","signals","channel","get","sizeType","getSizeSignalRef","push","name","assembleAxes","axisComponents","x","y","a","filter"],"sourceRoot":"","sources":["../../../../src/compile/axis/assemble.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module","externalDependencies":[]}