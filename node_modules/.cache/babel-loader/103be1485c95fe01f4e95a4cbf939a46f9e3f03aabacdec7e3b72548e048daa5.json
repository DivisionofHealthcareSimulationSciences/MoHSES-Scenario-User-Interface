{"ast":null,"code":"import { isArray, isBoolean, isNumber, isString } from 'vega-util';\nimport { isAggregateOp, isArgmaxDef, isArgminDef, isCountingAggregateOp } from './aggregate';\nimport { autoMaxBins, binToString, isBinned, isBinning } from './bin';\nimport { ANGLE, COLOR, COLUMN, DESCRIPTION, DETAIL, FACET, FILL, FILLOPACITY, getSizeChannel, HREF, isScaleChannel, isSecondaryRangeChannel, isXorY, KEY, LATITUDE, LATITUDE2, LONGITUDE, LONGITUDE2, OPACITY, ORDER, RADIUS, RADIUS2, ROW, SHAPE, SIZE, STROKE, STROKEDASH, STROKEOPACITY, STROKEWIDTH, TEXT, THETA, THETA2, TOOLTIP, URL, X, X2, XOFFSET, Y, Y2, YOFFSET } from './channel';\nimport { getMarkConfig, getMarkPropOrConfig } from './compile/common';\nimport { isCustomFormatType } from './compile/format';\nimport { dateTimeToExpr, isDateTime } from './datetime';\nimport { isExprRef } from './expr';\nimport * as log from './log';\nimport { isRectBasedMark } from './mark';\nimport { hasDiscreteDomain, isContinuousToDiscrete, SCALE_CATEGORY_INDEX } from './scale';\nimport { isSortByChannel } from './sort';\nimport { isFacetFieldDef } from './spec/facet';\nimport { getTimeUnitParts, isLocalSingleTimeUnit, normalizeTimeUnit, timeUnitToString } from './timeunit';\nimport { getFullName, QUANTITATIVE } from './type';\nimport { flatAccessWithDatum, getFirstDefined, internalField, omit, removePathFromField, replacePathInField, stringify, titleCase } from './util';\nimport { isSignalRef } from './vega.schema';\nexport function isConditionalParameter(c) {\n  return c['param'];\n}\nexport function isRepeatRef(field) {\n  return field && !isString(field) && 'repeat' in field;\n}\nexport function toFieldDefBase(fieldDef) {\n  const {\n    field,\n    timeUnit,\n    bin,\n    aggregate\n  } = fieldDef;\n  return {\n    ...(timeUnit ? {\n      timeUnit\n    } : {}),\n    ...(bin ? {\n      bin\n    } : {}),\n    ...(aggregate ? {\n      aggregate\n    } : {}),\n    field\n  };\n}\nexport function isSortableFieldDef(fieldDef) {\n  return 'sort' in fieldDef;\n}\nexport function getBandPosition({\n  fieldDef,\n  fieldDef2,\n  markDef: mark,\n  config\n}) {\n  if (isFieldOrDatumDef(fieldDef) && fieldDef.bandPosition !== undefined) {\n    return fieldDef.bandPosition;\n  }\n  if (isFieldDef(fieldDef)) {\n    const {\n      timeUnit,\n      bin\n    } = fieldDef;\n    if (timeUnit && !fieldDef2) {\n      return isRectBasedMark(mark.type) ? 0 : getMarkConfig('timeUnitBandPosition', mark, config);\n    } else if (isBinning(bin)) {\n      return 0.5;\n    }\n  }\n  return undefined;\n}\nexport function getBandSize({\n  channel,\n  fieldDef,\n  fieldDef2,\n  markDef: mark,\n  config,\n  scaleType,\n  useVlSizeChannel\n}) {\n  const sizeChannel = getSizeChannel(channel);\n  const size = getMarkPropOrConfig(useVlSizeChannel ? 'size' : sizeChannel, mark, config, {\n    vgChannel: sizeChannel\n  });\n  if (size !== undefined) {\n    return size;\n  }\n  if (isFieldDef(fieldDef)) {\n    const {\n      timeUnit,\n      bin\n    } = fieldDef;\n    if (timeUnit && !fieldDef2) {\n      return {\n        band: getMarkConfig('timeUnitBandSize', mark, config)\n      };\n    } else if (isBinning(bin) && !hasDiscreteDomain(scaleType)) {\n      return {\n        band: 1\n      };\n    }\n  }\n  if (isRectBasedMark(mark.type)) {\n    if (scaleType) {\n      if (hasDiscreteDomain(scaleType)) {\n        return config[mark.type]?.discreteBandSize || {\n          band: 1\n        };\n      } else {\n        return config[mark.type]?.continuousBandSize;\n      }\n    }\n    return config[mark.type]?.discreteBandSize;\n  }\n  return undefined;\n}\nexport function hasBandEnd(fieldDef, fieldDef2, markDef, config) {\n  if (isBinning(fieldDef.bin) || fieldDef.timeUnit && isTypedFieldDef(fieldDef) && fieldDef.type === 'temporal') {\n    // Need to check bandPosition because non-rect marks (e.g., point) with timeUnit\n    // doesn't have to use bandEnd if there is no bandPosition.\n    return getBandPosition({\n      fieldDef,\n      fieldDef2,\n      markDef,\n      config\n    }) !== undefined;\n  }\n  return false;\n}\nexport function isConditionalDef(channelDef) {\n  return channelDef && 'condition' in channelDef;\n}\n/**\n * Return if a channelDef is a ConditionalValueDef with ConditionFieldDef\n */\nexport function hasConditionalFieldDef(channelDef) {\n  const condition = channelDef?.['condition'];\n  return !!condition && !isArray(condition) && isFieldDef(condition);\n}\nexport function hasConditionalFieldOrDatumDef(channelDef) {\n  const condition = channelDef?.['condition'];\n  return !!condition && !isArray(condition) && isFieldOrDatumDef(condition);\n}\nexport function hasConditionalValueDef(channelDef) {\n  const condition = channelDef?.['condition'];\n  return !!condition && (isArray(condition) || isValueDef(condition));\n}\nexport function isFieldDef(channelDef) {\n  // TODO: we can't use field in channelDef here as it's somehow failing runtime test\n  return channelDef && (!!channelDef['field'] || channelDef['aggregate'] === 'count');\n}\nexport function channelDefType(channelDef) {\n  return channelDef?.['type'];\n}\nexport function isDatumDef(channelDef) {\n  return channelDef && 'datum' in channelDef;\n}\nexport function isContinuousFieldOrDatumDef(cd) {\n  // TODO: make datum support DateTime object\n  return isTypedFieldDef(cd) && !isDiscrete(cd) || isNumericDataDef(cd);\n}\nexport function isUnbinnedQuantitativeFieldOrDatumDef(cd) {\n  // TODO: make datum support DateTime object\n  return isTypedFieldDef(cd) && cd.type === 'quantitative' && !cd.bin || isNumericDataDef(cd);\n}\nexport function isNumericDataDef(cd) {\n  return isDatumDef(cd) && isNumber(cd.datum);\n}\nexport function isFieldOrDatumDef(channelDef) {\n  return isFieldDef(channelDef) || isDatumDef(channelDef);\n}\nexport function isTypedFieldDef(channelDef) {\n  return channelDef && ('field' in channelDef || channelDef['aggregate'] === 'count') && 'type' in channelDef;\n}\nexport function isValueDef(channelDef) {\n  return channelDef && 'value' in channelDef && 'value' in channelDef;\n}\nexport function isScaleFieldDef(channelDef) {\n  return channelDef && ('scale' in channelDef || 'sort' in channelDef);\n}\nexport function isPositionFieldOrDatumDef(channelDef) {\n  return channelDef && ('axis' in channelDef || 'stack' in channelDef || 'impute' in channelDef);\n}\nexport function isMarkPropFieldOrDatumDef(channelDef) {\n  return channelDef && 'legend' in channelDef;\n}\nexport function isStringFieldOrDatumDef(channelDef) {\n  return channelDef && ('format' in channelDef || 'formatType' in channelDef);\n}\nexport function toStringFieldDef(fieldDef) {\n  // omit properties that don't exist in string field defs\n  return omit(fieldDef, ['legend', 'axis', 'header', 'scale']);\n}\nfunction isOpFieldDef(fieldDef) {\n  return 'op' in fieldDef;\n}\n/**\n * Get a Vega field reference from a Vega-Lite field def.\n */\nexport function vgField(fieldDef, opt = {}) {\n  let field = fieldDef.field;\n  const prefix = opt.prefix;\n  let suffix = opt.suffix;\n  let argAccessor = ''; // for accessing argmin/argmax field at the end without getting escaped\n  if (isCount(fieldDef)) {\n    field = internalField('count');\n  } else {\n    let fn;\n    if (!opt.nofn) {\n      if (isOpFieldDef(fieldDef)) {\n        fn = fieldDef.op;\n      } else {\n        const {\n          bin,\n          aggregate,\n          timeUnit\n        } = fieldDef;\n        if (isBinning(bin)) {\n          fn = binToString(bin);\n          suffix = (opt.binSuffix ?? '') + (opt.suffix ?? '');\n        } else if (aggregate) {\n          if (isArgmaxDef(aggregate)) {\n            argAccessor = `[\"${field}\"]`;\n            field = `argmax_${aggregate.argmax}`;\n          } else if (isArgminDef(aggregate)) {\n            argAccessor = `[\"${field}\"]`;\n            field = `argmin_${aggregate.argmin}`;\n          } else {\n            fn = String(aggregate);\n          }\n        } else if (timeUnit) {\n          fn = timeUnitToString(timeUnit);\n          suffix = (!['range', 'mid'].includes(opt.binSuffix) && opt.binSuffix || '') + (opt.suffix ?? '');\n        }\n      }\n    }\n    if (fn) {\n      field = field ? `${fn}_${field}` : fn;\n    }\n  }\n  if (suffix) {\n    field = `${field}_${suffix}`;\n  }\n  if (prefix) {\n    field = `${prefix}_${field}`;\n  }\n  if (opt.forAs) {\n    return removePathFromField(field);\n  } else if (opt.expr) {\n    // Expression to access flattened field. No need to escape dots.\n    return flatAccessWithDatum(field, opt.expr) + argAccessor;\n  } else {\n    // We flattened all fields so paths should have become dot.\n    return replacePathInField(field) + argAccessor;\n  }\n}\nexport function isDiscrete(def) {\n  switch (def.type) {\n    case 'nominal':\n    case 'ordinal':\n    case 'geojson':\n      return true;\n    case 'quantitative':\n      return isFieldDef(def) && !!def.bin;\n    case 'temporal':\n      return false;\n  }\n  throw new Error(log.message.invalidFieldType(def.type));\n}\nexport function isDiscretizing(def) {\n  return isScaleFieldDef(def) && isContinuousToDiscrete(def.scale?.type);\n}\nexport function isCount(fieldDef) {\n  return fieldDef.aggregate === 'count';\n}\nexport function verbalTitleFormatter(fieldDef, config) {\n  const {\n    field,\n    bin,\n    timeUnit,\n    aggregate\n  } = fieldDef;\n  if (aggregate === 'count') {\n    return config.countTitle;\n  } else if (isBinning(bin)) {\n    return `${field} (binned)`;\n  } else if (timeUnit) {\n    const unit = normalizeTimeUnit(timeUnit)?.unit;\n    if (unit) {\n      return `${field} (${getTimeUnitParts(unit).join('-')})`;\n    }\n  } else if (aggregate) {\n    if (isArgmaxDef(aggregate)) {\n      return `${field} for max ${aggregate.argmax}`;\n    } else if (isArgminDef(aggregate)) {\n      return `${field} for min ${aggregate.argmin}`;\n    } else {\n      return `${titleCase(aggregate)} of ${field}`;\n    }\n  }\n  return field;\n}\nexport function functionalTitleFormatter(fieldDef) {\n  const {\n    aggregate,\n    bin,\n    timeUnit,\n    field\n  } = fieldDef;\n  if (isArgmaxDef(aggregate)) {\n    return `${field} for argmax(${aggregate.argmax})`;\n  } else if (isArgminDef(aggregate)) {\n    return `${field} for argmin(${aggregate.argmin})`;\n  }\n  const timeUnitParams = normalizeTimeUnit(timeUnit);\n  const fn = aggregate || timeUnitParams?.unit || timeUnitParams?.maxbins && 'timeunit' || isBinning(bin) && 'bin';\n  if (fn) {\n    return `${fn.toUpperCase()}(${field})`;\n  } else {\n    return field;\n  }\n}\nexport const defaultTitleFormatter = (fieldDef, config) => {\n  switch (config.fieldTitle) {\n    case 'plain':\n      return fieldDef.field;\n    case 'functional':\n      return functionalTitleFormatter(fieldDef);\n    default:\n      return verbalTitleFormatter(fieldDef, config);\n  }\n};\nlet titleFormatter = defaultTitleFormatter;\nexport function setTitleFormatter(formatter) {\n  titleFormatter = formatter;\n}\nexport function resetTitleFormatter() {\n  setTitleFormatter(defaultTitleFormatter);\n}\nexport function title(fieldOrDatumDef, config, {\n  allowDisabling,\n  includeDefault = true\n}) {\n  const guideTitle = getGuide(fieldOrDatumDef)?.title;\n  if (!isFieldDef(fieldOrDatumDef)) {\n    return guideTitle ?? fieldOrDatumDef.title;\n  }\n  const fieldDef = fieldOrDatumDef;\n  const def = includeDefault ? defaultTitle(fieldDef, config) : undefined;\n  if (allowDisabling) {\n    return getFirstDefined(guideTitle, fieldDef.title, def);\n  } else {\n    return guideTitle ?? fieldDef.title ?? def;\n  }\n}\nexport function getGuide(fieldDef) {\n  if (isPositionFieldOrDatumDef(fieldDef) && fieldDef.axis) {\n    return fieldDef.axis;\n  } else if (isMarkPropFieldOrDatumDef(fieldDef) && fieldDef.legend) {\n    return fieldDef.legend;\n  } else if (isFacetFieldDef(fieldDef) && fieldDef.header) {\n    return fieldDef.header;\n  }\n  return undefined;\n}\nexport function defaultTitle(fieldDef, config) {\n  return titleFormatter(fieldDef, config);\n}\nexport function getFormatMixins(fieldDef) {\n  if (isStringFieldOrDatumDef(fieldDef)) {\n    const {\n      format,\n      formatType\n    } = fieldDef;\n    return {\n      format,\n      formatType\n    };\n  } else {\n    const guide = getGuide(fieldDef) ?? {};\n    const {\n      format,\n      formatType\n    } = guide;\n    return {\n      format,\n      formatType\n    };\n  }\n}\nexport function defaultType(fieldDef, channel) {\n  switch (channel) {\n    case 'latitude':\n    case 'longitude':\n      return 'quantitative';\n    case 'row':\n    case 'column':\n    case 'facet':\n    case 'shape':\n    case 'strokeDash':\n      return 'nominal';\n    case 'order':\n      return 'ordinal';\n  }\n  if (isSortableFieldDef(fieldDef) && isArray(fieldDef.sort)) {\n    return 'ordinal';\n  }\n  const {\n    aggregate,\n    bin,\n    timeUnit\n  } = fieldDef;\n  if (timeUnit) {\n    return 'temporal';\n  }\n  if (bin || aggregate && !isArgmaxDef(aggregate) && !isArgminDef(aggregate)) {\n    return 'quantitative';\n  }\n  if (isScaleFieldDef(fieldDef) && fieldDef.scale?.type) {\n    switch (SCALE_CATEGORY_INDEX[fieldDef.scale.type]) {\n      case 'numeric':\n      case 'discretizing':\n        return 'quantitative';\n      case 'time':\n        return 'temporal';\n    }\n  }\n  return 'nominal';\n}\n/**\n * Returns the fieldDef -- either from the outer channelDef or from the condition of channelDef.\n * @param channelDef\n */\nexport function getFieldDef(channelDef) {\n  if (isFieldDef(channelDef)) {\n    return channelDef;\n  } else if (hasConditionalFieldDef(channelDef)) {\n    return channelDef.condition;\n  }\n  return undefined;\n}\nexport function getFieldOrDatumDef(channelDef) {\n  if (isFieldOrDatumDef(channelDef)) {\n    return channelDef;\n  } else if (hasConditionalFieldOrDatumDef(channelDef)) {\n    return channelDef.condition;\n  }\n  return undefined;\n}\n/**\n * Convert type to full, lowercase type, or augment the fieldDef with a default type if missing.\n */\nexport function initChannelDef(channelDef, channel, config, opt = {}) {\n  if (isString(channelDef) || isNumber(channelDef) || isBoolean(channelDef)) {\n    const primitiveType = isString(channelDef) ? 'string' : isNumber(channelDef) ? 'number' : 'boolean';\n    log.warn(log.message.primitiveChannelDef(channel, primitiveType, channelDef));\n    return {\n      value: channelDef\n    };\n  }\n  // If a fieldDef contains a field, we need type.\n  if (isFieldOrDatumDef(channelDef)) {\n    return initFieldOrDatumDef(channelDef, channel, config, opt);\n  } else if (hasConditionalFieldOrDatumDef(channelDef)) {\n    return {\n      ...channelDef,\n      // Need to cast as normalizeFieldDef normally return FieldDef, but here we know that it is definitely Condition<FieldDef>\n      condition: initFieldOrDatumDef(channelDef.condition, channel, config, opt)\n    };\n  }\n  return channelDef;\n}\nexport function initFieldOrDatumDef(fd, channel, config, opt) {\n  if (isStringFieldOrDatumDef(fd)) {\n    const {\n      format,\n      formatType,\n      ...rest\n    } = fd;\n    if (isCustomFormatType(formatType) && !config.customFormatTypes) {\n      log.warn(log.message.customFormatTypeNotAllowed(channel));\n      return initFieldOrDatumDef(rest, channel, config, opt);\n    }\n  } else {\n    const guideType = isPositionFieldOrDatumDef(fd) ? 'axis' : isMarkPropFieldOrDatumDef(fd) ? 'legend' : isFacetFieldDef(fd) ? 'header' : null;\n    if (guideType && fd[guideType]) {\n      const {\n        format,\n        formatType,\n        ...newGuide\n      } = fd[guideType];\n      if (isCustomFormatType(formatType) && !config.customFormatTypes) {\n        log.warn(log.message.customFormatTypeNotAllowed(channel));\n        return initFieldOrDatumDef({\n          ...fd,\n          [guideType]: newGuide\n        }, channel, config, opt);\n      }\n    }\n  }\n  if (isFieldDef(fd)) {\n    return initFieldDef(fd, channel, opt);\n  }\n  return initDatumDef(fd);\n}\nfunction initDatumDef(datumDef) {\n  let type = datumDef['type'];\n  if (type) {\n    return datumDef;\n  }\n  const {\n    datum\n  } = datumDef;\n  type = isNumber(datum) ? 'quantitative' : isString(datum) ? 'nominal' : isDateTime(datum) ? 'temporal' : undefined;\n  return {\n    ...datumDef,\n    type\n  };\n}\nexport function initFieldDef(fd, channel, {\n  compositeMark = false\n} = {}) {\n  const {\n    aggregate,\n    timeUnit,\n    bin,\n    field\n  } = fd;\n  const fieldDef = {\n    ...fd\n  };\n  // Drop invalid aggregate\n  if (!compositeMark && aggregate && !isAggregateOp(aggregate) && !isArgmaxDef(aggregate) && !isArgminDef(aggregate)) {\n    log.warn(log.message.invalidAggregate(aggregate));\n    delete fieldDef.aggregate;\n  }\n  // Normalize Time Unit\n  if (timeUnit) {\n    fieldDef.timeUnit = normalizeTimeUnit(timeUnit);\n  }\n  if (field) {\n    fieldDef.field = `${field}`;\n  }\n  // Normalize bin\n  if (isBinning(bin)) {\n    fieldDef.bin = normalizeBin(bin, channel);\n  }\n  if (isBinned(bin) && !isXorY(channel)) {\n    log.warn(log.message.channelShouldNotBeUsedForBinned(channel));\n  }\n  // Normalize Type\n  if (isTypedFieldDef(fieldDef)) {\n    const {\n      type\n    } = fieldDef;\n    const fullType = getFullName(type);\n    if (type !== fullType) {\n      // convert short type to full type\n      fieldDef.type = fullType;\n    }\n    if (type !== 'quantitative') {\n      if (isCountingAggregateOp(aggregate)) {\n        log.warn(log.message.invalidFieldTypeForCountAggregate(type, aggregate));\n        fieldDef.type = 'quantitative';\n      }\n    }\n  } else if (!isSecondaryRangeChannel(channel)) {\n    // If type is empty / invalid, then augment with default type\n    const newType = defaultType(fieldDef, channel);\n    fieldDef['type'] = newType;\n  }\n  if (isTypedFieldDef(fieldDef)) {\n    const {\n      compatible,\n      warning\n    } = channelCompatibility(fieldDef, channel) || {};\n    if (compatible === false) {\n      log.warn(warning);\n    }\n  }\n  if (isSortableFieldDef(fieldDef) && isString(fieldDef.sort)) {\n    const {\n      sort\n    } = fieldDef;\n    if (isSortByChannel(sort)) {\n      return {\n        ...fieldDef,\n        sort: {\n          encoding: sort\n        }\n      };\n    }\n    const sub = sort.substr(1);\n    if (sort.charAt(0) === '-' && isSortByChannel(sub)) {\n      return {\n        ...fieldDef,\n        sort: {\n          encoding: sub,\n          order: 'descending'\n        }\n      };\n    }\n  }\n  if (isFacetFieldDef(fieldDef)) {\n    const {\n      header\n    } = fieldDef;\n    if (header) {\n      const {\n        orient,\n        ...rest\n      } = header;\n      if (orient) {\n        return {\n          ...fieldDef,\n          header: {\n            ...rest,\n            labelOrient: header.labelOrient || orient,\n            titleOrient: header.titleOrient || orient\n          }\n        };\n      }\n    }\n  }\n  return fieldDef;\n}\nexport function normalizeBin(bin, channel) {\n  if (isBoolean(bin)) {\n    return {\n      maxbins: autoMaxBins(channel)\n    };\n  } else if (bin === 'binned') {\n    return {\n      binned: true\n    };\n  } else if (!bin.maxbins && !bin.step) {\n    return {\n      ...bin,\n      maxbins: autoMaxBins(channel)\n    };\n  } else {\n    return bin;\n  }\n}\nconst COMPATIBLE = {\n  compatible: true\n};\nexport function channelCompatibility(fieldDef, channel) {\n  const type = fieldDef.type;\n  if (type === 'geojson' && channel !== 'shape') {\n    return {\n      compatible: false,\n      warning: `Channel ${channel} should not be used with a geojson data.`\n    };\n  }\n  switch (channel) {\n    case ROW:\n    case COLUMN:\n    case FACET:\n      if (!isDiscrete(fieldDef)) {\n        return {\n          compatible: false,\n          warning: log.message.channelShouldBeDiscrete(channel)\n        };\n      }\n      return COMPATIBLE;\n    case X:\n    case Y:\n    case XOFFSET:\n    case YOFFSET:\n    case COLOR:\n    case FILL:\n    case STROKE:\n    case TEXT:\n    case DETAIL:\n    case KEY:\n    case TOOLTIP:\n    case HREF:\n    case URL:\n    case ANGLE:\n    case THETA:\n    case RADIUS:\n    case DESCRIPTION:\n      return COMPATIBLE;\n    case LONGITUDE:\n    case LONGITUDE2:\n    case LATITUDE:\n    case LATITUDE2:\n      if (type !== QUANTITATIVE) {\n        return {\n          compatible: false,\n          warning: `Channel ${channel} should be used with a quantitative field only, not ${fieldDef.type} field.`\n        };\n      }\n      return COMPATIBLE;\n    case OPACITY:\n    case FILLOPACITY:\n    case STROKEOPACITY:\n    case STROKEWIDTH:\n    case SIZE:\n    case THETA2:\n    case RADIUS2:\n    case X2:\n    case Y2:\n      if (type === 'nominal' && !fieldDef['sort']) {\n        return {\n          compatible: false,\n          warning: `Channel ${channel} should not be used with an unsorted discrete field.`\n        };\n      }\n      return COMPATIBLE;\n    case SHAPE:\n    case STROKEDASH:\n      if (!isDiscrete(fieldDef) && !isDiscretizing(fieldDef)) {\n        return {\n          compatible: false,\n          warning: log.message.channelShouldBeDiscreteOrDiscretizing(channel)\n        };\n      }\n      return COMPATIBLE;\n    case ORDER:\n      if (fieldDef.type === 'nominal' && !('sort' in fieldDef)) {\n        return {\n          compatible: false,\n          warning: `Channel order is inappropriate for nominal field, which has no inherent order.`\n        };\n      }\n      return COMPATIBLE;\n  }\n}\n/**\n * Check if the field def uses a time format or does not use any format but is temporal\n * (this does not cover field defs that are temporal but use a number format).\n */\nexport function isFieldOrDatumDefForTimeFormat(fieldOrDatumDef) {\n  const {\n    formatType\n  } = getFormatMixins(fieldOrDatumDef);\n  return formatType === 'time' || !formatType && isTimeFieldDef(fieldOrDatumDef);\n}\n/**\n * Check if field def has type `temporal`. If you want to also cover field defs that use a time format, use `isTimeFormatFieldDef`.\n */\nexport function isTimeFieldDef(def) {\n  return def && (def['type'] === 'temporal' || isFieldDef(def) && !!def.timeUnit);\n}\n/**\n * Getting a value associated with a fielddef.\n * Convert the value to Vega expression if applicable (for datetime object, or string if the field def is temporal or has timeUnit)\n */\nexport function valueExpr(v, {\n  timeUnit,\n  type,\n  wrapTime,\n  undefinedIfExprNotRequired\n}) {\n  const unit = timeUnit && normalizeTimeUnit(timeUnit)?.unit;\n  let isTime = unit || type === 'temporal';\n  let expr;\n  if (isExprRef(v)) {\n    expr = v.expr;\n  } else if (isSignalRef(v)) {\n    expr = v.signal;\n  } else if (isDateTime(v)) {\n    isTime = true;\n    expr = dateTimeToExpr(v);\n  } else if (isString(v) || isNumber(v)) {\n    if (isTime) {\n      expr = `datetime(${stringify(v)})`;\n      if (isLocalSingleTimeUnit(unit)) {\n        // for single timeUnit, we will use dateTimeToExpr to convert number/string to match the timeUnit\n        if (isNumber(v) && v < 10000 || isString(v) && isNaN(Date.parse(v))) {\n          expr = dateTimeToExpr({\n            [unit]: v\n          });\n        }\n      }\n    }\n  }\n  if (expr) {\n    return wrapTime && isTime ? `time(${expr})` : expr;\n  }\n  // number or boolean or normal string\n  return undefinedIfExprNotRequired ? undefined : stringify(v);\n}\n/**\n * Standardize value array -- convert each value to Vega expression if applicable\n */\nexport function valueArray(fieldOrDatumDef, values) {\n  const {\n    type\n  } = fieldOrDatumDef;\n  return values.map(v => {\n    const expr = valueExpr(v, {\n      timeUnit: isFieldDef(fieldOrDatumDef) ? fieldOrDatumDef.timeUnit : undefined,\n      type,\n      undefinedIfExprNotRequired: true\n    });\n    // return signal for the expression if we need an expression\n    if (expr !== undefined) {\n      return {\n        signal: expr\n      };\n    }\n    // otherwise just return the original value\n    return v;\n  });\n}\n/**\n * Checks whether a fieldDef for a particular channel requires a computed bin range.\n */\nexport function binRequiresRange(fieldDef, channel) {\n  if (!isBinning(fieldDef.bin)) {\n    console.warn('Only call this method for binned field defs.');\n    return false;\n  }\n  // We need the range only when the user explicitly forces a binned field to be use discrete scale. In this case, bin range is used in axis and legend labels.\n  // We could check whether the axis or legend exists (not disabled) but that seems overkill.\n  return isScaleChannel(channel) && ['ordinal', 'nominal'].includes(fieldDef.type);\n}","map":{"version":3,"mappings":"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","names":["isArray","isBoolean","isNumber","isString","isAggregateOp","isArgmaxDef","isArgminDef","isCountingAggregateOp","autoMaxBins","binToString","isBinned","isBinning","ANGLE","COLOR","COLUMN","DESCRIPTION","DETAIL","FACET","FILL","FILLOPACITY","getSizeChannel","HREF","isScaleChannel","isSecondaryRangeChannel","isXorY","KEY","LATITUDE","LATITUDE2","LONGITUDE","LONGITUDE2","OPACITY","ORDER","RADIUS","RADIUS2","ROW","SHAPE","SIZE","STROKE","STROKEDASH","STROKEOPACITY","STROKEWIDTH","TEXT","THETA","THETA2","TOOLTIP","URL","X","X2","XOFFSET","Y","Y2","YOFFSET","getMarkConfig","getMarkPropOrConfig","isCustomFormatType","dateTimeToExpr","isDateTime","isExprRef","log","isRectBasedMark","hasDiscreteDomain","isContinuousToDiscrete","SCALE_CATEGORY_INDEX","isSortByChannel","isFacetFieldDef","getTimeUnitParts","isLocalSingleTimeUnit","normalizeTimeUnit","timeUnitToString","getFullName","QUANTITATIVE","flatAccessWithDatum","getFirstDefined","internalField","omit","removePathFromField","replacePathInField","stringify","titleCase","isSignalRef","isConditionalParameter","c","isRepeatRef","field","toFieldDefBase","fieldDef","timeUnit","bin","aggregate","isSortableFieldDef","getBandPosition","fieldDef2","markDef","mark","config","isFieldOrDatumDef","bandPosition","undefined","isFieldDef","type","getBandSize","channel","scaleType","useVlSizeChannel","sizeChannel","size","vgChannel","band","discreteBandSize","continuousBandSize","hasBandEnd","isTypedFieldDef","isConditionalDef","channelDef","hasConditionalFieldDef","condition","hasConditionalFieldOrDatumDef","hasConditionalValueDef","isValueDef","channelDefType","isDatumDef","isContinuousFieldOrDatumDef","cd","isDiscrete","isNumericDataDef","isUnbinnedQuantitativeFieldOrDatumDef","datum","isScaleFieldDef","isPositionFieldOrDatumDef","isMarkPropFieldOrDatumDef","isStringFieldOrDatumDef","toStringFieldDef","isOpFieldDef","vgField","opt","prefix","suffix","argAccessor","isCount","fn","nofn","op","binSuffix","argmax","argmin","String","includes","forAs","expr","def","Error","message","invalidFieldType","isDiscretizing","scale","verbalTitleFormatter","countTitle","unit","join","functionalTitleFormatter","timeUnitParams","maxbins","toUpperCase","defaultTitleFormatter","fieldTitle","titleFormatter","setTitleFormatter","formatter","resetTitleFormatter","title","fieldOrDatumDef","allowDisabling","includeDefault","guideTitle","getGuide","defaultTitle","axis","legend","header","getFormatMixins","format","formatType","guide","defaultType","sort","getFieldDef","getFieldOrDatumDef","initChannelDef","primitiveType","warn","primitiveChannelDef","value","initFieldOrDatumDef","fd","rest","customFormatTypes","customFormatTypeNotAllowed","guideType","newGuide","initFieldDef","initDatumDef","datumDef","compositeMark","invalidAggregate","normalizeBin","channelShouldNotBeUsedForBinned","fullType","invalidFieldTypeForCountAggregate","newType","compatible","warning","channelCompatibility","encoding","sub","substr","charAt","order","orient","labelOrient","titleOrient","binned","step","COMPATIBLE","channelShouldBeDiscrete","channelShouldBeDiscreteOrDiscretizing","isFieldOrDatumDefForTimeFormat","isTimeFieldDef","valueExpr","v","wrapTime","undefinedIfExprNotRequired","isTime","signal","isNaN","Date","parse","valueArray","values","map","binRequiresRange","console"],"sourceRoot":"","sources":["../../src/channeldef.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module","externalDependencies":[]}