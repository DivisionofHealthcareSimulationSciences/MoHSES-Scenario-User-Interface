{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { isObject } from 'vega-util';\nimport { normalizeEncoding } from '../encoding';\nimport { isMarkDef } from '../mark';\nimport { isUnitSpec } from '../spec/unit';\nimport { stack } from '../stack';\nimport { keys, omit, pick } from '../util';\nfunction dropLineAndPoint(markDef) {\n  const {\n    point: _point,\n    line: _line,\n    ...mark\n  } = markDef;\n  return keys(mark).length > 1 ? mark : mark.type;\n}\nfunction dropLineAndPointFromConfig(config) {\n  for (const mark of ['line', 'area', 'rule', 'trail']) {\n    if (config[mark]) {\n      config = {\n        ...config,\n        // TODO: remove as any\n        [mark]: omit(config[mark], ['point', 'line'])\n      };\n    }\n  }\n  return config;\n}\nfunction getPointOverlay(markDef, markConfig = {}, encoding) {\n  if (markDef.point === 'transparent') {\n    return {\n      opacity: 0\n    };\n  } else if (markDef.point) {\n    // truthy : true or object\n    return isObject(markDef.point) ? markDef.point : {};\n  } else if (markDef.point !== undefined) {\n    // false or null\n    return null;\n  } else {\n    // undefined (not disabled)\n    if (markConfig.point || encoding.shape) {\n      // enable point overlay if config[mark].point is truthy or if encoding.shape is provided\n      return isObject(markConfig.point) ? markConfig.point : {};\n    }\n    // markDef.point is defined as falsy\n    return undefined;\n  }\n}\nfunction getLineOverlay(markDef, markConfig = {}) {\n  if (markDef.line) {\n    // true or object\n    return markDef.line === true ? {} : markDef.line;\n  } else if (markDef.line !== undefined) {\n    // false or null\n    return null;\n  } else {\n    // undefined (not disabled)\n    if (markConfig.line) {\n      // enable line overlay if config[mark].line is truthy\n      return markConfig.line === true ? {} : markConfig.line;\n    }\n    // markDef.point is defined as falsy\n    return undefined;\n  }\n}\nexport class PathOverlayNormalizer {\n  constructor() {\n    this.name = 'path-overlay';\n  }\n  hasMatchingType(spec, config) {\n    if (isUnitSpec(spec)) {\n      const {\n        mark,\n        encoding\n      } = spec;\n      const markDef = isMarkDef(mark) ? mark : {\n        type: mark\n      };\n      switch (markDef.type) {\n        case 'line':\n        case 'rule':\n        case 'trail':\n          return !!getPointOverlay(markDef, config[markDef.type], encoding);\n        case 'area':\n          return (\n            // false / null are also included as we want to remove the properties\n            !!getPointOverlay(markDef, config[markDef.type], encoding) || !!getLineOverlay(markDef, config[markDef.type])\n          );\n      }\n    }\n    return false;\n  }\n  run(spec, normParams, normalize) {\n    const {\n      config\n    } = normParams;\n    const {\n      params,\n      projection,\n      mark,\n      name,\n      encoding: e,\n      ...outerSpec\n    } = spec;\n    // Need to call normalizeEncoding because we need the inferred types to correctly determine stack\n    const encoding = normalizeEncoding(e, config);\n    const markDef = isMarkDef(mark) ? mark : {\n      type: mark\n    };\n    const pointOverlay = getPointOverlay(markDef, config[markDef.type], encoding);\n    const lineOverlay = markDef.type === 'area' && getLineOverlay(markDef, config[markDef.type]);\n    const layer = [{\n      name,\n      ...(params ? {\n        params\n      } : {}),\n      mark: dropLineAndPoint({\n        // TODO: extract this 0.7 to be shared with default opacity for point/tick/...\n        ...(markDef.type === 'area' && markDef.opacity === undefined && markDef.fillOpacity === undefined ? {\n          opacity: 0.7\n        } : {}),\n        ...markDef\n      }),\n      // drop shape from encoding as this might be used to trigger point overlay\n      encoding: omit(encoding, ['shape'])\n    }];\n    // FIXME: determine rules for applying selections.\n    // Need to copy stack config to overlayed layer\n    const stackProps = stack(markDef, encoding);\n    let overlayEncoding = encoding;\n    if (stackProps) {\n      const {\n        fieldChannel: stackFieldChannel,\n        offset\n      } = stackProps;\n      overlayEncoding = {\n        ...encoding,\n        [stackFieldChannel]: {\n          ...encoding[stackFieldChannel],\n          ...(offset ? {\n            stack: offset\n          } : {})\n        }\n      };\n    }\n    // overlay line layer should be on the edge of area but passing y2/x2 makes\n    // it as \"rule\" mark so that it draws unwanted vertical/horizontal lines.\n    // point overlay also should not have y2/x2 as it does not support.\n    overlayEncoding = omit(overlayEncoding, ['y2', 'x2']);\n    if (lineOverlay) {\n      layer.push({\n        ...(projection ? {\n          projection\n        } : {}),\n        mark: {\n          type: 'line',\n          ...pick(markDef, ['clip', 'interpolate', 'tension', 'tooltip']),\n          ...lineOverlay\n        },\n        encoding: overlayEncoding\n      });\n    }\n    if (pointOverlay) {\n      layer.push({\n        ...(projection ? {\n          projection\n        } : {}),\n        mark: {\n          type: 'point',\n          opacity: 1,\n          filled: true,\n          ...pick(markDef, ['clip', 'tooltip']),\n          ...pointOverlay\n        },\n        encoding: overlayEncoding\n      });\n    }\n    return normalize({\n      ...outerSpec,\n      layer\n    }, {\n      ...normParams,\n      config: dropLineAndPointFromConfig(config)\n    });\n  }\n}","map":{"version":3,"mappings":"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","names":["isObject","normalizeEncoding","isMarkDef","isUnitSpec","stack","keys","omit","pick","dropLineAndPoint","markDef","point","_point","line","_line","mark","length","type","dropLineAndPointFromConfig","config","getPointOverlay","markConfig","encoding","opacity","undefined","shape","getLineOverlay","PathOverlayNormalizer","constructor","hasMatchingType","spec","run","normParams","normalize","params","projection","name","e","outerSpec","pointOverlay","lineOverlay","layer","fillOpacity","stackProps","overlayEncoding","fieldChannel","stackFieldChannel","offset","push","filled"],"sourceRoot":"","sources":["../../../src/normalize/pathoverlay.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module","externalDependencies":[]}