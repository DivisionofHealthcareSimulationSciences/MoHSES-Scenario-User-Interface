{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.regexp.flags.js\";\nimport { identity, array, isFunction, constant, isArray, id, error, truthy, debounce, extend, visitArray, inherits, logger, Error, hasOwnProperty } from 'vega-util';\nimport { read, responseType, loader } from 'vega-loader';\nimport { defaultLocale } from 'vega-format';\nfunction UniqueList(idFunc) {\n  const $ = idFunc || identity,\n    list = [],\n    ids = {};\n  list.add = _ => {\n    const id = $(_);\n    if (!ids[id]) {\n      ids[id] = 1;\n      list.push(_);\n    }\n    return list;\n  };\n  list.remove = _ => {\n    const id = $(_);\n    if (ids[id]) {\n      ids[id] = 0;\n      const idx = list.indexOf(_);\n      if (idx >= 0) list.splice(idx, 1);\n    }\n    return list;\n  };\n  return list;\n}\n\n/**\r\n * Invoke and await a potentially async callback function. If\r\n * an error occurs, trap it and route to Dataflow.error.\r\n * @param {Dataflow} df - The dataflow instance\r\n * @param {function} callback - A callback function to invoke\r\n *   and then await. The dataflow will be passed as the single\r\n *   argument to the function.\r\n */\nasync function asyncCallback(df, callback) {\n  try {\n    await callback(df);\n  } catch (err) {\n    df.error(err);\n  }\n}\nconst TUPLE_ID_KEY = Symbol('vega_id');\nlet TUPLE_ID = 1;\n\n/**\r\n * Checks if an input value is a registered tuple.\r\n * @param {*} t - The value to check.\r\n * @return {boolean} True if the input is a tuple, false otherwise.\r\n */\nfunction isTuple(t) {\n  return !!(t && tupleid(t));\n}\n\n/**\r\n * Returns the id of a tuple.\r\n * @param {object} t - The input tuple.\r\n * @return {*} the tuple id.\r\n */\nfunction tupleid(t) {\n  return t[TUPLE_ID_KEY];\n}\n\n/**\r\n * Sets the id of a tuple.\r\n * @param {object} t - The input tuple.\r\n * @param {*} id - The id value to set.\r\n * @return {object} the input tuple.\r\n */\nfunction setid(t, id) {\n  t[TUPLE_ID_KEY] = id;\n  return t;\n}\n\n/**\r\n * Ingest an object or value as a data tuple.\r\n * If the input value is an object, an id field will be added to it. For\r\n * efficiency, the input object is modified directly. A copy is not made.\r\n * If the input value is a literal, it will be wrapped in a new object\r\n * instance, with the value accessible as the 'data' property.\r\n * @param datum - The value to ingest.\r\n * @return {object} The ingested data tuple.\r\n */\nfunction ingest$1(datum) {\n  const t = datum === Object(datum) ? datum : {\n    data: datum\n  };\n  return tupleid(t) ? t : setid(t, TUPLE_ID++);\n}\n\n/**\r\n * Given a source tuple, return a derived copy.\r\n * @param {object} t - The source tuple.\r\n * @return {object} The derived tuple.\r\n */\nfunction derive(t) {\n  return rederive(t, ingest$1({}));\n}\n\n/**\r\n * Rederive a derived tuple by copying values from the source tuple.\r\n * @param {object} t - The source tuple.\r\n * @param {object} d - The derived tuple.\r\n * @return {object} The derived tuple.\r\n */\nfunction rederive(t, d) {\n  for (const k in t) d[k] = t[k];\n  return d;\n}\n\n/**\r\n * Replace an existing tuple with a new tuple.\r\n * @param {object} t - The existing data tuple.\r\n * @param {object} d - The new tuple that replaces the old.\r\n * @return {object} The new tuple.\r\n */\nfunction replace(t, d) {\n  return setid(d, tupleid(t));\n}\n\n/**\r\n * Generate an augmented comparator function that provides stable\r\n * sorting by tuple id when the given comparator produces ties.\r\n * @param {function} cmp - The comparator to augment.\r\n * @param {function} [f] - Optional tuple accessor function.\r\n * @return {function} An augmented comparator function.\r\n */\nfunction stableCompare(cmp, f) {\n  return !cmp ? null : f ? (a, b) => cmp(a, b) || tupleid(f(a)) - tupleid(f(b)) : (a, b) => cmp(a, b) || tupleid(a) - tupleid(b);\n}\nfunction isChangeSet(v) {\n  return v && v.constructor === changeset;\n}\nfunction changeset() {\n  const add = [],\n    // insert tuples\n    rem = [],\n    // remove tuples\n    mod = [],\n    // modify tuples\n    remp = [],\n    // remove by predicate\n    modp = []; // modify by predicate\n  let clean = null,\n    reflow = false;\n  return {\n    constructor: changeset,\n    insert(t) {\n      const d = array(t),\n        n = d.length;\n      for (let i = 0; i < n; ++i) add.push(d[i]);\n      return this;\n    },\n    remove(t) {\n      const a = isFunction(t) ? remp : rem,\n        d = array(t),\n        n = d.length;\n      for (let i = 0; i < n; ++i) a.push(d[i]);\n      return this;\n    },\n    modify(t, field, value) {\n      const m = {\n        field: field,\n        value: constant(value)\n      };\n      if (isFunction(t)) {\n        m.filter = t;\n        modp.push(m);\n      } else {\n        m.tuple = t;\n        mod.push(m);\n      }\n      return this;\n    },\n    encode(t, set) {\n      if (isFunction(t)) modp.push({\n        filter: t,\n        field: set\n      });else mod.push({\n        tuple: t,\n        field: set\n      });\n      return this;\n    },\n    clean(value) {\n      clean = value;\n      return this;\n    },\n    reflow() {\n      reflow = true;\n      return this;\n    },\n    pulse(pulse, tuples) {\n      const cur = {},\n        out = {};\n      let i, n, m, f, t, id;\n\n      // build lookup table of current tuples\n      for (i = 0, n = tuples.length; i < n; ++i) {\n        cur[tupleid(tuples[i])] = 1;\n      }\n\n      // process individual tuples to remove\n      for (i = 0, n = rem.length; i < n; ++i) {\n        t = rem[i];\n        cur[tupleid(t)] = -1;\n      }\n\n      // process predicate-based removals\n      for (i = 0, n = remp.length; i < n; ++i) {\n        f = remp[i];\n        tuples.forEach(t => {\n          if (f(t)) cur[tupleid(t)] = -1;\n        });\n      }\n\n      // process all add tuples\n      for (i = 0, n = add.length; i < n; ++i) {\n        t = add[i];\n        id = tupleid(t);\n        if (cur[id]) {\n          // tuple already resides in dataset\n          // if flagged for both add and remove, cancel\n          cur[id] = 1;\n        } else {\n          // tuple does not reside in dataset, add\n          pulse.add.push(ingest$1(add[i]));\n        }\n      }\n\n      // populate pulse rem list\n      for (i = 0, n = tuples.length; i < n; ++i) {\n        t = tuples[i];\n        if (cur[tupleid(t)] < 0) pulse.rem.push(t);\n      }\n\n      // modify helper method\n      function modify(t, f, v) {\n        if (v) {\n          t[f] = v(t);\n        } else {\n          pulse.encode = f;\n        }\n        if (!reflow) out[tupleid(t)] = t;\n      }\n\n      // process individual tuples to modify\n      for (i = 0, n = mod.length; i < n; ++i) {\n        m = mod[i];\n        t = m.tuple;\n        f = m.field;\n        id = cur[tupleid(t)];\n        if (id > 0) {\n          modify(t, f, m.value);\n          pulse.modifies(f);\n        }\n      }\n\n      // process predicate-based modifications\n      for (i = 0, n = modp.length; i < n; ++i) {\n        m = modp[i];\n        f = m.filter;\n        tuples.forEach(t => {\n          if (f(t) && cur[tupleid(t)] > 0) {\n            modify(t, m.field, m.value);\n          }\n        });\n        pulse.modifies(m.field);\n      }\n\n      // upon reflow request, populate mod with all non-removed tuples\n      // otherwise, populate mod with modified tuples only\n      if (reflow) {\n        pulse.mod = rem.length || remp.length ? tuples.filter(t => cur[tupleid(t)] > 0) : tuples.slice();\n      } else {\n        for (id in out) pulse.mod.push(out[id]);\n      }\n\n      // set pulse garbage collection request\n      if (clean || clean == null && (rem.length || remp.length)) {\n        pulse.clean(true);\n      }\n      return pulse;\n    }\n  };\n}\nconst CACHE = '_:mod:_';\n\n/**\r\n * Hash that tracks modifications to assigned values.\r\n * Callers *must* use the set method to update values.\r\n */\nfunction Parameters() {\n  Object.defineProperty(this, CACHE, {\n    writable: true,\n    value: {}\n  });\n}\nParameters.prototype = {\n  /**\r\n   * Set a parameter value. If the parameter value changes, the parameter\r\n   * will be recorded as modified.\r\n   * @param {string} name - The parameter name.\r\n   * @param {number} index - The index into an array-value parameter. Ignored if\r\n   *   the argument is undefined, null or less than zero.\r\n   * @param {*} value - The parameter value to set.\r\n   * @param {boolean} [force=false] - If true, records the parameter as modified\r\n   *   even if the value is unchanged.\r\n   * @return {Parameters} - This parameter object.\r\n   */\n  set(name, index, value, force) {\n    const o = this,\n      v = o[name],\n      mod = o[CACHE];\n    if (index != null && index >= 0) {\n      if (v[index] !== value || force) {\n        v[index] = value;\n        mod[index + ':' + name] = -1;\n        mod[name] = -1;\n      }\n    } else if (v !== value || force) {\n      o[name] = value;\n      mod[name] = isArray(value) ? 1 + value.length : -1;\n    }\n    return o;\n  },\n  /**\r\n   * Tests if one or more parameters has been modified. If invoked with no\r\n   * arguments, returns true if any parameter value has changed. If the first\r\n   * argument is array, returns trues if any parameter name in the array has\r\n   * changed. Otherwise, tests if the given name and optional array index has\r\n   * changed.\r\n   * @param {string} name - The parameter name to test.\r\n   * @param {number} [index=undefined] - The parameter array index to test.\r\n   * @return {boolean} - Returns true if a queried parameter was modified.\r\n   */\n  modified(name, index) {\n    const mod = this[CACHE];\n    if (!arguments.length) {\n      for (const k in mod) {\n        if (mod[k]) return true;\n      }\n      return false;\n    } else if (isArray(name)) {\n      for (let k = 0; k < name.length; ++k) {\n        if (mod[name[k]]) return true;\n      }\n      return false;\n    }\n    return index != null && index >= 0 ? index + 1 < mod[name] || !!mod[index + ':' + name] : !!mod[name];\n  },\n  /**\r\n   * Clears the modification records. After calling this method,\r\n   * all parameters are considered unmodified.\r\n   */\n  clear() {\n    this[CACHE] = {};\n    return this;\n  }\n};\nlet OP_ID = 0;\nconst PULSE = 'pulse',\n  NO_PARAMS = new Parameters();\n\n// Boolean Flags\nconst SKIP$1 = 1,\n  MODIFIED = 2;\n\n/**\r\n * An Operator is a processing node in a dataflow graph.\r\n * Each operator stores a value and an optional value update function.\r\n * Operators can accept a hash of named parameters. Parameter values can\r\n * either be direct (JavaScript literals, arrays, objects) or indirect\r\n * (other operators whose values will be pulled dynamically). Operators\r\n * included as parameters will have this operator added as a dependency.\r\n * @constructor\r\n * @param {*} [init] - The initial value for this operator.\r\n * @param {function(object, Pulse)} [update] - An update function. Upon\r\n *   evaluation of this operator, the update function will be invoked and the\r\n *   return value will be used as the new value of this operator.\r\n * @param {object} [params] - The parameters for this operator.\r\n * @param {boolean} [react=true] - Flag indicating if this operator should\r\n *   listen for changes to upstream operators included as parameters.\r\n * @see parameters\r\n */\nfunction Operator(init, update, params, react) {\n  this.id = ++OP_ID;\n  this.value = init;\n  this.stamp = -1;\n  this.rank = -1;\n  this.qrank = -1;\n  this.flags = 0;\n  if (update) {\n    this._update = update;\n  }\n  if (params) this.parameters(params, react);\n}\nfunction flag(bit) {\n  return function (state) {\n    const f = this.flags;\n    if (arguments.length === 0) return !!(f & bit);\n    this.flags = state ? f | bit : f & ~bit;\n    return this;\n  };\n}\nOperator.prototype = {\n  /**\r\n   * Returns a list of target operators dependent on this operator.\r\n   * If this list does not exist, it is created and then returned.\r\n   * @return {UniqueList}\r\n   */\n  targets() {\n    return this._targets || (this._targets = UniqueList(id));\n  },\n  /**\r\n   * Sets the value of this operator.\r\n   * @param {*} value - the value to set.\r\n   * @return {Number} Returns 1 if the operator value has changed\r\n   *   according to strict equality, returns 0 otherwise.\r\n   */\n  set(value) {\n    if (this.value !== value) {\n      this.value = value;\n      return 1;\n    } else {\n      return 0;\n    }\n  },\n  /**\r\n   * Indicates that operator evaluation should be skipped on the next pulse.\r\n   * This operator will still propagate incoming pulses, but its update function\r\n   * will not be invoked. The skip flag is reset after every pulse, so calling\r\n   * this method will affect processing of the next pulse only.\r\n   */\n  skip: flag(SKIP$1),\n  /**\r\n   * Indicates that this operator's value has been modified on its most recent\r\n   * pulse. Normally modification is checked via strict equality; however, in\r\n   * some cases it is more efficient to update the internal state of an object.\r\n   * In those cases, the modified flag can be used to trigger propagation. Once\r\n   * set, the modification flag persists across pulses until unset. The flag can\r\n   * be used with the last timestamp to test if a modification is recent.\r\n   */\n  modified: flag(MODIFIED),\n  /**\r\n   * Sets the parameters for this operator. The parameter values are analyzed for\r\n   * operator instances. If found, this operator will be added as a dependency\r\n   * of the parameterizing operator. Operator values are dynamically marshalled\r\n   * from each operator parameter prior to evaluation. If a parameter value is\r\n   * an array, the array will also be searched for Operator instances. However,\r\n   * the search does not recurse into sub-arrays or object properties.\r\n   * @param {object} params - A hash of operator parameters.\r\n   * @param {boolean} [react=true] - A flag indicating if this operator should\r\n   *   automatically update (react) when parameter values change. In other words,\r\n   *   this flag determines if the operator registers itself as a listener on\r\n   *   any upstream operators included in the parameters.\r\n   * @param {boolean} [initonly=false] - A flag indicating if this operator\r\n   *   should calculate an update only upon its initial evaluation, then\r\n   *   deregister dependencies and suppress all future update invocations.\r\n   * @return {Operator[]} - An array of upstream dependencies.\r\n   */\n  parameters(params, react, initonly) {\n    react = react !== false;\n    const argval = this._argval = this._argval || new Parameters(),\n      argops = this._argops = this._argops || [],\n      deps = [];\n    let name, value, n, i;\n    const add = (name, index, value) => {\n      if (value instanceof Operator) {\n        if (value !== this) {\n          if (react) value.targets().add(this);\n          deps.push(value);\n        }\n        argops.push({\n          op: value,\n          name: name,\n          index: index\n        });\n      } else {\n        argval.set(name, index, value);\n      }\n    };\n    for (name in params) {\n      value = params[name];\n      if (name === PULSE) {\n        array(value).forEach(op => {\n          if (!(op instanceof Operator)) {\n            error('Pulse parameters must be operator instances.');\n          } else if (op !== this) {\n            op.targets().add(this);\n            deps.push(op);\n          }\n        });\n        this.source = value;\n      } else if (isArray(value)) {\n        argval.set(name, -1, Array(n = value.length));\n        for (i = 0; i < n; ++i) add(name, i, value[i]);\n      } else {\n        add(name, -1, value);\n      }\n    }\n    this.marshall().clear(); // initialize values\n    if (initonly) argops.initonly = true;\n    return deps;\n  },\n  /**\r\n   * Internal method for marshalling parameter values.\r\n   * Visits each operator dependency to pull the latest value.\r\n   * @return {Parameters} A Parameters object to pass to the update function.\r\n   */\n  marshall(stamp) {\n    const argval = this._argval || NO_PARAMS,\n      argops = this._argops;\n    let item, i, op, mod;\n    if (argops) {\n      const n = argops.length;\n      for (i = 0; i < n; ++i) {\n        item = argops[i];\n        op = item.op;\n        mod = op.modified() && op.stamp === stamp;\n        argval.set(item.name, item.index, op.value, mod);\n      }\n      if (argops.initonly) {\n        for (i = 0; i < n; ++i) {\n          item = argops[i];\n          item.op.targets().remove(this);\n        }\n        this._argops = null;\n        this._update = null;\n      }\n    }\n    return argval;\n  },\n  /**\r\n   * Detach this operator from the dataflow.\r\n   * Unregisters listeners on upstream dependencies.\r\n   */\n  detach() {\n    const argops = this._argops;\n    let i, n, item, op;\n    if (argops) {\n      for (i = 0, n = argops.length; i < n; ++i) {\n        item = argops[i];\n        op = item.op;\n        if (op._targets) {\n          op._targets.remove(this);\n        }\n      }\n    }\n\n    // remove references to the source and pulse object,\n    // if present, to prevent memory leaks of old data.\n    this.pulse = null;\n    this.source = null;\n  },\n  /**\r\n   * Delegate method to perform operator processing.\r\n   * Subclasses can override this method to perform custom processing.\r\n   * By default, it marshalls parameters and calls the update function\r\n   * if that function is defined. If the update function does not\r\n   * change the operator value then StopPropagation is returned.\r\n   * If no update function is defined, this method does nothing.\r\n   * @param {Pulse} pulse - the current dataflow pulse.\r\n   * @return The output pulse or StopPropagation. A falsy return value\r\n   *   (including undefined) will let the input pulse pass through.\r\n   */\n  evaluate(pulse) {\n    const update = this._update;\n    if (update) {\n      const params = this.marshall(pulse.stamp),\n        v = update.call(this, params, pulse);\n      params.clear();\n      if (v !== this.value) {\n        this.value = v;\n      } else if (!this.modified()) {\n        return pulse.StopPropagation;\n      }\n    }\n  },\n  /**\r\n   * Run this operator for the current pulse. If this operator has already\r\n   * been run at (or after) the pulse timestamp, returns StopPropagation.\r\n   * Internally, this method calls {@link evaluate} to perform processing.\r\n   * If {@link evaluate} returns a falsy value, the input pulse is returned.\r\n   * This method should NOT be overridden, instead overrride {@link evaluate}.\r\n   * @param {Pulse} pulse - the current dataflow pulse.\r\n   * @return the output pulse for this operator (or StopPropagation)\r\n   */\n  run(pulse) {\n    if (pulse.stamp < this.stamp) return pulse.StopPropagation;\n    let rv;\n    if (this.skip()) {\n      this.skip(false);\n      rv = 0;\n    } else {\n      rv = this.evaluate(pulse);\n    }\n    return this.pulse = rv || pulse;\n  }\n};\n\n/**\r\n * Add an operator to the dataflow graph. This function accepts a\r\n * variety of input argument types. The basic signature supports an\r\n * initial value, update function and parameters. If the first parameter\r\n * is an Operator instance, it will be added directly. If it is a\r\n * constructor for an Operator subclass, a new instance will be instantiated.\r\n * Otherwise, if the first parameter is a function instance, it will be used\r\n * as the update function and a null initial value is assumed.\r\n * @param {*} init - One of: the operator to add, the initial value of\r\n *   the operator, an operator class to instantiate, or an update function.\r\n * @param {function} [update] - The operator update function.\r\n * @param {object} [params] - The operator parameters.\r\n * @param {boolean} [react=true] - Flag indicating if this operator should\r\n *   listen for changes to upstream operators included as parameters.\r\n * @return {Operator} - The added operator.\r\n */\nfunction add(init, update, params, react) {\n  let shift = 1,\n    op;\n  if (init instanceof Operator) {\n    op = init;\n  } else if (init && init.prototype instanceof Operator) {\n    op = new init();\n  } else if (isFunction(init)) {\n    op = new Operator(null, init);\n  } else {\n    shift = 0;\n    op = new Operator(init, update);\n  }\n  this.rank(op);\n  if (shift) {\n    react = params;\n    params = update;\n  }\n  if (params) this.connect(op, op.parameters(params, react));\n  this.touch(op);\n  return op;\n}\n\n/**\r\n * Connect a target operator as a dependent of source operators.\r\n * If necessary, this method will rerank the target operator and its\r\n * dependents to ensure propagation proceeds in a topologically sorted order.\r\n * @param {Operator} target - The target operator.\r\n * @param {Array<Operator>} - The source operators that should propagate\r\n *   to the target operator.\r\n */\nfunction connect(target, sources) {\n  const targetRank = target.rank,\n    n = sources.length;\n  for (let i = 0; i < n; ++i) {\n    if (targetRank < sources[i].rank) {\n      this.rerank(target);\n      return;\n    }\n  }\n}\nlet STREAM_ID = 0;\n\n/**\r\n * Models an event stream.\r\n * @constructor\r\n * @param {function(Object, number): boolean} [filter] - Filter predicate.\r\n *   Events pass through when truthy, events are suppressed when falsy.\r\n * @param {function(Object): *} [apply] - Applied to input events to produce\r\n *   new event values.\r\n * @param {function(Object)} [receive] - Event callback function to invoke\r\n *   upon receipt of a new event. Use to override standard event processing.\r\n */\nfunction EventStream(filter, apply, receive) {\n  this.id = ++STREAM_ID;\n  this.value = null;\n  if (receive) this.receive = receive;\n  if (filter) this._filter = filter;\n  if (apply) this._apply = apply;\n}\n\n/**\r\n * Creates a new event stream instance with the provided\r\n * (optional) filter, apply and receive functions.\r\n * @param {function(Object, number): boolean} [filter] - Filter predicate.\r\n *   Events pass through when truthy, events are suppressed when falsy.\r\n * @param {function(Object): *} [apply] - Applied to input events to produce\r\n *   new event values.\r\n * @see EventStream\r\n */\nfunction stream(filter, apply, receive) {\n  return new EventStream(filter, apply, receive);\n}\nEventStream.prototype = {\n  _filter: truthy,\n  _apply: identity,\n  targets() {\n    return this._targets || (this._targets = UniqueList(id));\n  },\n  consume(_) {\n    if (!arguments.length) return !!this._consume;\n    this._consume = !!_;\n    return this;\n  },\n  receive(evt) {\n    if (this._filter(evt)) {\n      const val = this.value = this._apply(evt),\n        trg = this._targets,\n        n = trg ? trg.length : 0;\n      for (let i = 0; i < n; ++i) trg[i].receive(val);\n      if (this._consume) {\n        evt.preventDefault();\n        evt.stopPropagation();\n      }\n    }\n  },\n  filter(filter) {\n    const s = stream(filter);\n    this.targets().add(s);\n    return s;\n  },\n  apply(apply) {\n    const s = stream(null, apply);\n    this.targets().add(s);\n    return s;\n  },\n  merge() {\n    const s = stream();\n    this.targets().add(s);\n    for (let i = 0, n = arguments.length; i < n; ++i) {\n      arguments[i].targets().add(s);\n    }\n    return s;\n  },\n  throttle(pause) {\n    let t = -1;\n    return this.filter(() => {\n      const now = Date.now();\n      if (now - t > pause) {\n        t = now;\n        return 1;\n      } else {\n        return 0;\n      }\n    });\n  },\n  debounce(delay) {\n    const s = stream();\n    this.targets().add(stream(null, null, debounce(delay, e => {\n      const df = e.dataflow;\n      s.receive(e);\n      if (df && df.run) df.run();\n    })));\n    return s;\n  },\n  between(a, b) {\n    let active = false;\n    a.targets().add(stream(null, null, () => active = true));\n    b.targets().add(stream(null, null, () => active = false));\n    return this.filter(() => active);\n  },\n  detach() {\n    // ensures compatibility with operators (#2753)\n    // remove references to other streams and filter functions that may\n    // be bound to subcontexts that need to be garbage collected.\n    this._filter = truthy;\n    this._targets = null;\n  }\n};\n\n/**\r\n * Create a new event stream from an event source.\r\n * @param {object} source - The event source to monitor. The input must\r\n *  support the addEventListener method.\r\n * @param {string} type - The event type.\r\n * @param {function(object): boolean} [filter] - Event filter function.\r\n * @param {function(object): *} [apply] - Event application function.\r\n *   If provided, this function will be invoked and the result will be\r\n *   used as the downstream event value.\r\n * @return {EventStream}\r\n */\nfunction events(source, type, filter, apply) {\n  const df = this,\n    s = stream(filter, apply),\n    send = function (e) {\n      e.dataflow = df;\n      try {\n        s.receive(e);\n      } catch (error) {\n        df.error(error);\n      } finally {\n        df.run();\n      }\n    };\n  let sources;\n  if (typeof source === 'string' && typeof document !== 'undefined') {\n    sources = document.querySelectorAll(source);\n  } else {\n    sources = array(source);\n  }\n  const n = sources.length;\n  for (let i = 0; i < n; ++i) {\n    sources[i].addEventListener(type, send);\n  }\n  return s;\n}\nfunction parse(data, format) {\n  const locale = this.locale();\n  return read(data, format, locale.timeParse, locale.utcParse);\n}\n\n/**\r\n * Ingests new data into the dataflow. First parses the data using the\r\n * vega-loader read method, then pulses a changeset to the target operator.\r\n * @param {Operator} target - The Operator to target with ingested data,\r\n *   typically a Collect transform instance.\r\n * @param {*} data - The input data, prior to parsing. For JSON this may\r\n *   be a string or an object. For CSV, TSV, etc should be a string.\r\n * @param {object} format - The data format description for parsing\r\n *   loaded data. This object is passed to the vega-loader read method.\r\n * @returns {Dataflow}\r\n */\nfunction ingest(target, data, format) {\n  data = this.parse(data, format);\n  return this.pulse(target, this.changeset().insert(data));\n}\n\n/**\r\n * Request data from an external source, parse it, and return a Promise.\r\n * @param {string} url - The URL from which to load the data. This string\r\n *   is passed to the vega-loader load method.\r\n * @param {object} [format] - The data format description for parsing\r\n *   loaded data. This object is passed to the vega-loader read method.\r\n * @return {Promise} A Promise that resolves upon completion of the request.\r\n *   The resolved object contains the following properties:\r\n *   - data: an array of parsed data (or null upon error)\r\n *   - status: a code for success (0), load fail (-1), or parse fail (-2)\r\n */\nasync function request(url, format) {\n  const df = this;\n  let status = 0,\n    data;\n  try {\n    data = await df.loader().load(url, {\n      context: 'dataflow',\n      response: responseType(format && format.type)\n    });\n    try {\n      data = df.parse(data, format);\n    } catch (err) {\n      status = -2;\n      df.warn('Data ingestion failed', url, err);\n    }\n  } catch (err) {\n    status = -1;\n    df.warn('Loading failed', url, err);\n  }\n  return {\n    data,\n    status\n  };\n}\nasync function preload(target, url, format) {\n  const df = this,\n    pending = df._pending || loadPending(df);\n  pending.requests += 1;\n  const res = await df.request(url, format);\n  df.pulse(target, df.changeset().remove(truthy).insert(res.data || []));\n  pending.done();\n  return res;\n}\nfunction loadPending(df) {\n  let accept;\n  const pending = new Promise(a => accept = a);\n  pending.requests = 0;\n  pending.done = () => {\n    if (--pending.requests === 0) {\n      df._pending = null;\n      accept(df);\n    }\n  };\n  return df._pending = pending;\n}\nconst SKIP = {\n  skip: true\n};\n\n/**\r\n * Perform operator updates in response to events. Applies an\r\n * update function to compute a new operator value. If the update function\r\n * returns a {@link ChangeSet}, the operator will be pulsed with those tuple\r\n * changes. Otherwise, the operator value will be updated to the return value.\r\n * @param {EventStream|Operator} source - The event source to react to.\r\n *   This argument can be either an EventStream or an Operator.\r\n * @param {Operator|function(object):Operator} target - The operator to update.\r\n *   This argument can either be an Operator instance or (if the source\r\n *   argument is an EventStream), a function that accepts an event object as\r\n *   input and returns an Operator to target.\r\n * @param {function(Parameters,Event): *} [update] - Optional update function\r\n *   to compute the new operator value, or a literal value to set. Update\r\n *   functions expect to receive a parameter object and event as arguments.\r\n *   This function can either return a new operator value or (if the source\r\n *   argument is an EventStream) a {@link ChangeSet} instance to pulse\r\n *   the target operator with tuple changes.\r\n * @param {object} [params] - The update function parameters.\r\n * @param {object} [options] - Additional options hash. If not overridden,\r\n *   updated operators will be skipped by default.\r\n * @param {boolean} [options.skip] - If true, the operator will\r\n *  be skipped: it will not be evaluated, but its dependents will be.\r\n * @param {boolean} [options.force] - If true, the operator will\r\n *   be re-evaluated even if its value has not changed.\r\n * @return {Dataflow}\r\n */\nfunction on(source, target, update, params, options) {\n  const fn = source instanceof Operator ? onOperator : onStream;\n  fn(this, source, target, update, params, options);\n  return this;\n}\nfunction onStream(df, stream, target, update, params, options) {\n  const opt = extend({}, options, SKIP);\n  let func, op;\n  if (!isFunction(target)) target = constant(target);\n  if (update === undefined) {\n    func = e => df.touch(target(e));\n  } else if (isFunction(update)) {\n    op = new Operator(null, update, params, false);\n    func = e => {\n      op.evaluate(e);\n      const t = target(e),\n        v = op.value;\n      isChangeSet(v) ? df.pulse(t, v, options) : df.update(t, v, opt);\n    };\n  } else {\n    func = e => df.update(target(e), update, opt);\n  }\n  stream.apply(func);\n}\nfunction onOperator(df, source, target, update, params, options) {\n  if (update === undefined) {\n    source.targets().add(target);\n  } else {\n    const opt = options || {},\n      op = new Operator(null, updater(target, update), params, false);\n    op.modified(opt.force);\n    op.rank = source.rank; // immediately follow source\n    source.targets().add(op); // add dependency\n\n    if (target) {\n      op.skip(true); // skip first invocation\n      op.value = target.value; // initialize value\n      op.targets().add(target); // chain dependencies\n      df.connect(target, [op]); // rerank as needed, #1672\n    }\n  }\n}\n\nfunction updater(target, update) {\n  update = isFunction(update) ? update : constant(update);\n  return target ? function (_, pulse) {\n    const value = update(_, pulse);\n    if (!target.skip()) {\n      target.skip(value !== this.value).value = value;\n    }\n    return value;\n  } : update;\n}\n\n/**\r\n * Assigns a rank to an operator. Ranks are assigned in increasing order\r\n * by incrementing an internal rank counter.\r\n * @param {Operator} op - The operator to assign a rank.\r\n */\nfunction rank(op) {\n  op.rank = ++this._rank;\n}\n\n/**\r\n * Re-ranks an operator and all downstream target dependencies. This\r\n * is necessary when upstream dependencies of higher rank are added to\r\n * a target operator.\r\n * @param {Operator} op - The operator to re-rank.\r\n */\nfunction rerank(op) {\n  const queue = [op];\n  let cur, list, i;\n  while (queue.length) {\n    this.rank(cur = queue.pop());\n    if (list = cur._targets) {\n      for (i = list.length; --i >= 0;) {\n        queue.push(cur = list[i]);\n        if (cur === op) error('Cycle detected in dataflow graph.');\n      }\n    }\n  }\n}\n\n/**\r\n * Sentinel value indicating pulse propagation should stop.\r\n */\nconst StopPropagation = {};\n\n// Pulse visit type flags\nconst ADD = 1 << 0,\n  REM = 1 << 1,\n  MOD = 1 << 2,\n  ADD_REM = ADD | REM,\n  ADD_MOD = ADD | MOD,\n  ALL = ADD | REM | MOD,\n  REFLOW = 1 << 3,\n  SOURCE = 1 << 4,\n  NO_SOURCE = 1 << 5,\n  NO_FIELDS = 1 << 6;\n\n/**\r\n * A Pulse enables inter-operator communication during a run of the\r\n * dataflow graph. In addition to the current timestamp, a pulse may also\r\n * contain a change-set of added, removed or modified data tuples, as well as\r\n * a pointer to a full backing data source. Tuple change sets may not\r\n * be fully materialized; for example, to prevent needless array creation\r\n * a change set may include larger arrays and corresponding filter functions.\r\n * The pulse provides a {@link visit} method to enable proper and efficient\r\n * iteration over requested data tuples.\r\n *\r\n * In addition, each pulse can track modification flags for data tuple fields.\r\n * Responsible transform operators should call the {@link modifies} method to\r\n * indicate changes to data fields. The {@link modified} method enables\r\n * querying of this modification state.\r\n *\r\n * @constructor\r\n * @param {Dataflow} dataflow - The backing dataflow instance.\r\n * @param {number} stamp - The current propagation timestamp.\r\n * @param {string} [encode] - An optional encoding set name, which is then\r\n *   accessible as Pulse.encode. Operators can respond to (or ignore) this\r\n *   setting as appropriate. This parameter can be used in conjunction with\r\n *   the Encode transform in the vega-encode module.\r\n */\nfunction Pulse(dataflow, stamp, encode) {\n  this.dataflow = dataflow;\n  this.stamp = stamp == null ? -1 : stamp;\n  this.add = [];\n  this.rem = [];\n  this.mod = [];\n  this.fields = null;\n  this.encode = encode || null;\n}\nfunction materialize(data, filter) {\n  const out = [];\n  visitArray(data, filter, _ => out.push(_));\n  return out;\n}\nfunction filter(pulse, flags) {\n  const map = {};\n  pulse.visit(flags, t => {\n    map[tupleid(t)] = 1;\n  });\n  return t => map[tupleid(t)] ? null : t;\n}\nfunction addFilter(a, b) {\n  return a ? (t, i) => a(t, i) && b(t, i) : b;\n}\nPulse.prototype = {\n  /**\r\n   * Sentinel value indicating pulse propagation should stop.\r\n   */\n  StopPropagation,\n  /**\r\n   * Boolean flag indicating ADD (added) tuples.\r\n   */\n  ADD,\n  /**\r\n   * Boolean flag indicating REM (removed) tuples.\r\n   */\n  REM,\n  /**\r\n   * Boolean flag indicating MOD (modified) tuples.\r\n   */\n  MOD,\n  /**\r\n   * Boolean flag indicating ADD (added) and REM (removed) tuples.\r\n   */\n  ADD_REM,\n  /**\r\n   * Boolean flag indicating ADD (added) and MOD (modified) tuples.\r\n   */\n  ADD_MOD,\n  /**\r\n   * Boolean flag indicating ADD, REM and MOD tuples.\r\n   */\n  ALL,\n  /**\r\n   * Boolean flag indicating all tuples in a data source\r\n   * except for the ADD, REM and MOD tuples.\r\n   */\n  REFLOW,\n  /**\r\n   * Boolean flag indicating a 'pass-through' to a\r\n   * backing data source, ignoring ADD, REM and MOD tuples.\r\n   */\n  SOURCE,\n  /**\r\n   * Boolean flag indicating that source data should be\r\n   * suppressed when creating a forked pulse.\r\n   */\n  NO_SOURCE,\n  /**\r\n   * Boolean flag indicating that field modifications should be\r\n   * suppressed when creating a forked pulse.\r\n   */\n  NO_FIELDS,\n  /**\r\n   * Creates a new pulse based on the values of this pulse.\r\n   * The dataflow, time stamp and field modification values are copied over.\r\n   * By default, new empty ADD, REM and MOD arrays are created.\r\n   * @param {number} flags - Integer of boolean flags indicating which (if any)\r\n   *   tuple arrays should be copied to the new pulse. The supported flag values\r\n   *   are ADD, REM and MOD. Array references are copied directly: new array\r\n   *   instances are not created.\r\n   * @return {Pulse} - The forked pulse instance.\r\n   * @see init\r\n   */\n  fork(flags) {\n    return new Pulse(this.dataflow).init(this, flags);\n  },\n  /**\r\n   * Creates a copy of this pulse with new materialized array\r\n   * instances for the ADD, REM, MOD, and SOURCE arrays.\r\n   * The dataflow, time stamp and field modification values are copied over.\r\n   * @return {Pulse} - The cloned pulse instance.\r\n   * @see init\r\n   */\n  clone() {\n    const p = this.fork(ALL);\n    p.add = p.add.slice();\n    p.rem = p.rem.slice();\n    p.mod = p.mod.slice();\n    if (p.source) p.source = p.source.slice();\n    return p.materialize(ALL | SOURCE);\n  },\n  /**\r\n   * Returns a pulse that adds all tuples from a backing source. This is\r\n   * useful for cases where operators are added to a dataflow after an\r\n   * upstream data pipeline has already been processed, ensuring that\r\n   * new operators can observe all tuples within a stream.\r\n   * @return {Pulse} - A pulse instance with all source tuples included\r\n   *   in the add array. If the current pulse already has all source\r\n   *   tuples in its add array, it is returned directly. If the current\r\n   *   pulse does not have a backing source, it is returned directly.\r\n   */\n  addAll() {\n    let p = this;\n    const reuse = !p.source || p.add === p.rem // special case for indexed set (e.g., crossfilter)\n    || !p.rem.length && p.source.length === p.add.length;\n    if (reuse) {\n      return p;\n    } else {\n      p = new Pulse(this.dataflow).init(this);\n      p.add = p.source;\n      p.rem = []; // new operators can ignore rem #2769\n      return p;\n    }\n  },\n  /**\r\n   * Initialize this pulse based on the values of another pulse. This method\r\n   * is used internally by {@link fork} to initialize a new forked tuple.\r\n   * The dataflow, time stamp and field modification values are copied over.\r\n   * By default, new empty ADD, REM and MOD arrays are created.\r\n   * @param {Pulse} src - The source pulse to copy from.\r\n   * @param {number} flags - Integer of boolean flags indicating which (if any)\r\n   *   tuple arrays should be copied to the new pulse. The supported flag values\r\n   *   are ADD, REM and MOD. Array references are copied directly: new array\r\n   *   instances are not created. By default, source data arrays are copied\r\n   *   to the new pulse. Use the NO_SOURCE flag to enforce a null source.\r\n   * @return {Pulse} - Returns this Pulse instance.\r\n   */\n  init(src, flags) {\n    const p = this;\n    p.stamp = src.stamp;\n    p.encode = src.encode;\n    if (src.fields && !(flags & NO_FIELDS)) {\n      p.fields = src.fields;\n    }\n    if (flags & ADD) {\n      p.addF = src.addF;\n      p.add = src.add;\n    } else {\n      p.addF = null;\n      p.add = [];\n    }\n    if (flags & REM) {\n      p.remF = src.remF;\n      p.rem = src.rem;\n    } else {\n      p.remF = null;\n      p.rem = [];\n    }\n    if (flags & MOD) {\n      p.modF = src.modF;\n      p.mod = src.mod;\n    } else {\n      p.modF = null;\n      p.mod = [];\n    }\n    if (flags & NO_SOURCE) {\n      p.srcF = null;\n      p.source = null;\n    } else {\n      p.srcF = src.srcF;\n      p.source = src.source;\n      if (src.cleans) p.cleans = src.cleans;\n    }\n    return p;\n  },\n  /**\r\n   * Schedules a function to run after pulse propagation completes.\r\n   * @param {function} func - The function to run.\r\n   */\n  runAfter(func) {\n    this.dataflow.runAfter(func);\n  },\n  /**\r\n   * Indicates if tuples have been added, removed or modified.\r\n   * @param {number} [flags] - The tuple types (ADD, REM or MOD) to query.\r\n   *   Defaults to ALL, returning true if any tuple type has changed.\r\n   * @return {boolean} - Returns true if one or more queried tuple types have\r\n   *   changed, false otherwise.\r\n   */\n  changed(flags) {\n    const f = flags || ALL;\n    return f & ADD && this.add.length || f & REM && this.rem.length || f & MOD && this.mod.length;\n  },\n  /**\r\n   * Forces a \"reflow\" of tuple values, such that all tuples in the backing\r\n   * source are added to the MOD set, unless already present in the ADD set.\r\n   * @param {boolean} [fork=false] - If true, returns a forked copy of this\r\n   *   pulse, and invokes reflow on that derived pulse.\r\n   * @return {Pulse} - The reflowed pulse instance.\r\n   */\n  reflow(fork) {\n    if (fork) return this.fork(ALL).reflow();\n    const len = this.add.length,\n      src = this.source && this.source.length;\n    if (src && src !== len) {\n      this.mod = this.source;\n      if (len) this.filter(MOD, filter(this, ADD));\n    }\n    return this;\n  },\n  /**\r\n   * Get/set metadata to pulse requesting garbage collection\r\n   * to reclaim currently unused resources.\r\n   */\n  clean(value) {\n    if (arguments.length) {\n      this.cleans = !!value;\n      return this;\n    } else {\n      return this.cleans;\n    }\n  },\n  /**\r\n   * Marks one or more data field names as modified to assist dependency\r\n   * tracking and incremental processing by transform operators.\r\n   * @param {string|Array<string>} _ - The field(s) to mark as modified.\r\n   * @return {Pulse} - This pulse instance.\r\n   */\n  modifies(_) {\n    const hash = this.fields || (this.fields = {});\n    if (isArray(_)) {\n      _.forEach(f => hash[f] = true);\n    } else {\n      hash[_] = true;\n    }\n    return this;\n  },\n  /**\r\n   * Checks if one or more data fields have been modified during this pulse\r\n   * propagation timestamp.\r\n   * @param {string|Array<string>} _ - The field(s) to check for modified.\r\n   * @param {boolean} nomod - If true, will check the modified flag even if\r\n   *   no mod tuples exist. If false (default), mod tuples must be present.\r\n   * @return {boolean} - Returns true if any of the provided fields has been\r\n   *   marked as modified, false otherwise.\r\n   */\n  modified(_, nomod) {\n    const fields = this.fields;\n    return !((nomod || this.mod.length) && fields) ? false : !arguments.length ? !!fields : isArray(_) ? _.some(f => fields[f]) : fields[_];\n  },\n  /**\r\n   * Adds a filter function to one more tuple sets. Filters are applied to\r\n   * backing tuple arrays, to determine the actual set of tuples considered\r\n   * added, removed or modified. They can be used to delay materialization of\r\n   * a tuple set in order to avoid expensive array copies. In addition, the\r\n   * filter functions can serve as value transformers: unlike standard predicate\r\n   * function (which return boolean values), Pulse filters should return the\r\n   * actual tuple value to process. If a tuple set is already filtered, the\r\n   * new filter function will be appended into a conjuntive ('and') query.\r\n   * @param {number} flags - Flags indicating the tuple set(s) to filter.\r\n   * @param {function(*):object} filter - Filter function that will be applied\r\n   *   to the tuple set array, and should return a data tuple if the value\r\n   *   should be included in the tuple set, and falsy (or null) otherwise.\r\n   * @return {Pulse} - Returns this pulse instance.\r\n   */\n  filter(flags, filter) {\n    const p = this;\n    if (flags & ADD) p.addF = addFilter(p.addF, filter);\n    if (flags & REM) p.remF = addFilter(p.remF, filter);\n    if (flags & MOD) p.modF = addFilter(p.modF, filter);\n    if (flags & SOURCE) p.srcF = addFilter(p.srcF, filter);\n    return p;\n  },\n  /**\r\n   * Materialize one or more tuple sets in this pulse. If the tuple set(s) have\r\n   * a registered filter function, it will be applied and the tuple set(s) will\r\n   * be replaced with materialized tuple arrays.\r\n   * @param {number} flags - Flags indicating the tuple set(s) to materialize.\r\n   * @return {Pulse} - Returns this pulse instance.\r\n   */\n  materialize(flags) {\n    flags = flags || ALL;\n    const p = this;\n    if (flags & ADD && p.addF) {\n      p.add = materialize(p.add, p.addF);\n      p.addF = null;\n    }\n    if (flags & REM && p.remF) {\n      p.rem = materialize(p.rem, p.remF);\n      p.remF = null;\n    }\n    if (flags & MOD && p.modF) {\n      p.mod = materialize(p.mod, p.modF);\n      p.modF = null;\n    }\n    if (flags & SOURCE && p.srcF) {\n      p.source = p.source.filter(p.srcF);\n      p.srcF = null;\n    }\n    return p;\n  },\n  /**\r\n   * Visit one or more tuple sets in this pulse.\r\n   * @param {number} flags - Flags indicating the tuple set(s) to visit.\r\n   *   Legal values are ADD, REM, MOD and SOURCE (if a backing data source\r\n   *   has been set).\r\n   * @param {function(object):*} - Visitor function invoked per-tuple.\r\n   * @return {Pulse} - Returns this pulse instance.\r\n   */\n  visit(flags, visitor) {\n    const p = this,\n      v = visitor;\n    if (flags & SOURCE) {\n      visitArray(p.source, p.srcF, v);\n      return p;\n    }\n    if (flags & ADD) visitArray(p.add, p.addF, v);\n    if (flags & REM) visitArray(p.rem, p.remF, v);\n    if (flags & MOD) visitArray(p.mod, p.modF, v);\n    const src = p.source;\n    if (flags & REFLOW && src) {\n      const sum = p.add.length + p.mod.length;\n      if (sum === src.length) ;else if (sum) {\n        visitArray(src, filter(p, ADD_MOD), v);\n      } else {\n        // if no add/rem/mod tuples, visit source\n        visitArray(src, p.srcF, v);\n      }\n    }\n    return p;\n  }\n};\n\n/**\r\n * Represents a set of multiple pulses. Used as input for operators\r\n * that accept multiple pulses at a time. Contained pulses are\r\n * accessible via the public \"pulses\" array property. This pulse doe\r\n * not carry added, removed or modified tuples directly. However,\r\n * the visit method can be used to traverse all such tuples contained\r\n * in sub-pulses with a timestamp matching this parent multi-pulse.\r\n * @constructor\r\n * @param {Dataflow} dataflow - The backing dataflow instance.\r\n * @param {number} stamp - The timestamp.\r\n * @param {Array<Pulse>} pulses - The sub-pulses for this multi-pulse.\r\n */\nfunction MultiPulse(dataflow, stamp, pulses, encode) {\n  const p = this;\n  let c = 0;\n  this.dataflow = dataflow;\n  this.stamp = stamp;\n  this.fields = null;\n  this.encode = encode || null;\n  this.pulses = pulses;\n  for (const pulse of pulses) {\n    if (pulse.stamp !== stamp) continue;\n    if (pulse.fields) {\n      const hash = p.fields || (p.fields = {});\n      for (const f in pulse.fields) {\n        hash[f] = 1;\n      }\n    }\n    if (pulse.changed(p.ADD)) c |= p.ADD;\n    if (pulse.changed(p.REM)) c |= p.REM;\n    if (pulse.changed(p.MOD)) c |= p.MOD;\n  }\n  this.changes = c;\n}\ninherits(MultiPulse, Pulse, {\n  /**\r\n   * Creates a new pulse based on the values of this pulse.\r\n   * The dataflow, time stamp and field modification values are copied over.\r\n   * @return {Pulse}\r\n   */\n  fork(flags) {\n    const p = new Pulse(this.dataflow).init(this, flags & this.NO_FIELDS);\n    if (flags !== undefined) {\n      if (flags & p.ADD) this.visit(p.ADD, t => p.add.push(t));\n      if (flags & p.REM) this.visit(p.REM, t => p.rem.push(t));\n      if (flags & p.MOD) this.visit(p.MOD, t => p.mod.push(t));\n    }\n    return p;\n  },\n  changed(flags) {\n    return this.changes & flags;\n  },\n  modified(_) {\n    const p = this,\n      fields = p.fields;\n    return !(fields && p.changes & p.MOD) ? 0 : isArray(_) ? _.some(f => fields[f]) : fields[_];\n  },\n  filter() {\n    error('MultiPulse does not support filtering.');\n  },\n  materialize() {\n    error('MultiPulse does not support materialization.');\n  },\n  visit(flags, visitor) {\n    const p = this,\n      pulses = p.pulses,\n      n = pulses.length;\n    let i = 0;\n    if (flags & p.SOURCE) {\n      for (; i < n; ++i) {\n        pulses[i].visit(flags, visitor);\n      }\n    } else {\n      for (; i < n; ++i) {\n        if (pulses[i].stamp === p.stamp) {\n          pulses[i].visit(flags, visitor);\n        }\n      }\n    }\n    return p;\n  }\n});\n\n/* eslint-disable require-atomic-updates */\n\n/**\r\n * Evaluates the dataflow and returns a Promise that resolves when pulse\r\n * propagation completes. This method will increment the current timestamp\r\n * and process all updated, pulsed and touched operators. When invoked for\r\n * the first time, all registered operators will be processed. This method\r\n * should not be invoked by third-party clients, use {@link runAsync} or\r\n * {@link run} instead.\r\n * @param {string} [encode] - The name of an encoding set to invoke during\r\n *   propagation. This value is added to generated Pulse instances;\r\n *   operators can then respond to (or ignore) this setting as appropriate.\r\n *   This parameter can be used in conjunction with the Encode transform in\r\n *   the vega-encode package.\r\n * @param {function} [prerun] - An optional callback function to invoke\r\n *   immediately before dataflow evaluation commences.\r\n * @param {function} [postrun] - An optional callback function to invoke\r\n *   after dataflow evaluation completes. The callback will be invoked\r\n *   after those registered via {@link runAfter}.\r\n * @return {Promise} - A promise that resolves to this dataflow after\r\n *   evaluation completes.\r\n */\nasync function evaluate(encode, prerun, postrun) {\n  const df = this,\n    async = [];\n\n  // if the pulse value is set, this is a re-entrant call\n  if (df._pulse) return reentrant(df);\n\n  // wait for pending datasets to load\n  if (df._pending) await df._pending;\n\n  // invoke prerun function, if provided\n  if (prerun) await asyncCallback(df, prerun);\n\n  // exit early if there are no updates\n  if (!df._touched.length) {\n    df.debug('Dataflow invoked, but nothing to do.');\n    return df;\n  }\n\n  // increment timestamp clock\n  const stamp = ++df._clock;\n\n  // set the current pulse\n  df._pulse = new Pulse(df, stamp, encode);\n\n  // initialize priority queue, reset touched operators\n  df._touched.forEach(op => df._enqueue(op, true));\n  df._touched = UniqueList(id);\n  let count = 0,\n    op,\n    next,\n    error;\n  try {\n    while (df._heap.size() > 0) {\n      // dequeue operator with highest priority\n      op = df._heap.pop();\n\n      // re-queue if rank changed\n      if (op.rank !== op.qrank) {\n        df._enqueue(op, true);\n        continue;\n      }\n\n      // otherwise, evaluate the operator\n      next = op.run(df._getPulse(op, encode));\n      if (next.then) {\n        // await if operator returns a promise directly\n        next = await next;\n      } else if (next.async) {\n        // queue parallel asynchronous execution\n        async.push(next.async);\n        next = StopPropagation;\n      }\n\n      // propagate evaluation, enqueue dependent operators\n      if (next !== StopPropagation) {\n        if (op._targets) op._targets.forEach(op => df._enqueue(op));\n      }\n\n      // increment visit counter\n      ++count;\n    }\n  } catch (err) {\n    df._heap.clear();\n    error = err;\n  }\n\n  // reset pulse map\n  df._input = {};\n  df._pulse = null;\n  df.debug(`Pulse ${stamp}: ${count} operators`);\n  if (error) {\n    df._postrun = [];\n    df.error(error);\n  }\n\n  // invoke callbacks queued via runAfter\n  if (df._postrun.length) {\n    const pr = df._postrun.sort((a, b) => b.priority - a.priority);\n    df._postrun = [];\n    for (let i = 0; i < pr.length; ++i) {\n      await asyncCallback(df, pr[i].callback);\n    }\n  }\n\n  // invoke postrun function, if provided\n  if (postrun) await asyncCallback(df, postrun);\n\n  // handle non-blocking asynchronous callbacks\n  if (async.length) {\n    Promise.all(async).then(cb => df.runAsync(null, () => {\n      cb.forEach(f => {\n        try {\n          f(df);\n        } catch (err) {\n          df.error(err);\n        }\n      });\n    }));\n  }\n  return df;\n}\n\n/**\r\n * Queues dataflow evaluation to run once any other queued evaluations have\r\n * completed and returns a Promise that resolves when the queued pulse\r\n * propagation completes. If provided, a callback function will be invoked\r\n * immediately before evaluation commences. This method will ensure a\r\n * separate evaluation is invoked for each time it is called.\r\n * @param {string} [encode] - The name of an encoding set to invoke during\r\n *   propagation. This value is added to generated Pulse instances;\r\n *   operators can then respond to (or ignore) this setting as appropriate.\r\n *   This parameter can be used in conjunction with the Encode transform in\r\n *   the vega-encode package.\r\n * @param {function} [prerun] - An optional callback function to invoke\r\n *   immediately before dataflow evaluation commences.\r\n * @param {function} [postrun] - An optional callback function to invoke\r\n *   after dataflow evaluation completes. The callback will be invoked\r\n *   after those registered via {@link runAfter}.\r\n * @return {Promise} - A promise that resolves to this dataflow after\r\n *   evaluation completes.\r\n */\nasync function runAsync(encode, prerun, postrun) {\n  // await previously queued functions\n  while (this._running) await this._running;\n\n  // run dataflow, manage running promise\n  const clear = () => this._running = null;\n  (this._running = this.evaluate(encode, prerun, postrun)).then(clear, clear);\n  return this._running;\n}\n\n/**\r\n * Requests dataflow evaluation and the immediately returns this dataflow\r\n * instance. If there are pending data loading or other asynchronous\r\n * operations, the dataflow will evaluate asynchronously after this method\r\n * has been invoked. To track when dataflow evaluation completes, use the\r\n * {@link runAsync} method instead. This method will raise an error if\r\n * invoked while the dataflow is already in the midst of evaluation.\r\n * @param {string} [encode] - The name of an encoding set to invoke during\r\n *   propagation. This value is added to generated Pulse instances;\r\n *   operators can then respond to (or ignore) this setting as appropriate.\r\n *   This parameter can be used in conjunction with the Encode transform in\r\n *   the vega-encode module.\r\n * @param {function} [prerun] - An optional callback function to invoke\r\n *   immediately before dataflow evaluation commences.\r\n * @param {function} [postrun] - An optional callback function to invoke\r\n *   after dataflow evaluation completes. The callback will be invoked\r\n *   after those registered via {@link runAfter}.\r\n * @return {Dataflow} - This dataflow instance.\r\n */\nfunction run(encode, prerun, postrun) {\n  return this._pulse ? reentrant(this) : (this.evaluate(encode, prerun, postrun), this);\n}\n\n/**\r\n * Schedules a callback function to be invoked after the current pulse\r\n * propagation completes. If no propagation is currently occurring,\r\n * the function is invoked immediately. Callbacks scheduled via runAfter\r\n * are invoked immediately upon completion of the current cycle, before\r\n * any request queued via runAsync. This method is primarily intended for\r\n * internal use. Third-party callers using runAfter to schedule a callback\r\n * that invokes {@link run} or {@link runAsync} should not use this method,\r\n * but instead use {@link runAsync} with prerun or postrun arguments.\r\n * @param {function(Dataflow)} callback - The callback function to run.\r\n *   The callback will be invoked with this Dataflow instance as its\r\n *   sole argument.\r\n * @param {boolean} enqueue - A boolean flag indicating that the\r\n *   callback should be queued up to run after the next propagation\r\n *   cycle, suppressing immediate invocation when propagation is not\r\n *   currently occurring.\r\n * @param {number} [priority] - A priority value used to sort registered\r\n *   callbacks to determine execution order. This argument is intended\r\n *   for internal Vega use only.\r\n */\nfunction runAfter(callback, enqueue, priority) {\n  if (this._pulse || enqueue) {\n    // pulse propagation is currently running, queue to run after\n    this._postrun.push({\n      priority: priority || 0,\n      callback: callback\n    });\n  } else {\n    // pulse propagation already complete, invoke immediately\n    try {\n      callback(this);\n    } catch (err) {\n      this.error(err);\n    }\n  }\n}\n\n/**\r\n * Raise an error for re-entrant dataflow evaluation.\r\n */\nfunction reentrant(df) {\n  df.error('Dataflow already running. Use runAsync() to chain invocations.');\n  return df;\n}\n\n/**\r\n * Enqueue an operator into the priority queue for evaluation. The operator\r\n * will be enqueued if it has no registered pulse for the current cycle, or if\r\n * the force argument is true. Upon enqueue, this method also sets the\r\n * operator's qrank to the current rank value.\r\n * @param {Operator} op - The operator to enqueue.\r\n * @param {boolean} [force] - A flag indicating if the operator should be\r\n *   forceably added to the queue, even if it has already been previously\r\n *   enqueued during the current pulse propagation. This is useful when the\r\n *   dataflow graph is dynamically modified and the operator rank changes.\r\n */\nfunction enqueue(op, force) {\n  const q = op.stamp < this._clock;\n  if (q) op.stamp = this._clock;\n  if (q || force) {\n    op.qrank = op.rank;\n    this._heap.push(op);\n  }\n}\n\n/**\r\n * Provide a correct pulse for evaluating an operator. If the operator has an\r\n * explicit source operator, we will try to pull the pulse(s) from it.\r\n * If there is an array of source operators, we build a multi-pulse.\r\n * Otherwise, we return a current pulse with correct source data.\r\n * If the pulse is the pulse map has an explicit target set, we use that.\r\n * Else if the pulse on the upstream source operator is current, we use that.\r\n * Else we use the pulse from the pulse map, but copy the source tuple array.\r\n * @param {Operator} op - The operator for which to get an input pulse.\r\n * @param {string} [encode] - An (optional) encoding set name with which to\r\n *   annotate the returned pulse. See {@link run} for more information.\r\n */\nfunction getPulse(op, encode) {\n  const s = op.source,\n    stamp = this._clock;\n  return s && isArray(s) ? new MultiPulse(this, stamp, s.map(_ => _.pulse), encode) : this._input[op.id] || singlePulse(this._pulse, s && s.pulse);\n}\nfunction singlePulse(p, s) {\n  if (s && s.stamp === p.stamp) {\n    return s;\n  }\n  p = p.fork();\n  if (s && s !== StopPropagation) {\n    p.source = s.source;\n  }\n  return p;\n}\nconst NO_OPT = {\n  skip: false,\n  force: false\n};\n\n/**\r\n * Touches an operator, scheduling it to be evaluated. If invoked outside of\r\n * a pulse propagation, the operator will be evaluated the next time this\r\n * dataflow is run. If invoked in the midst of pulse propagation, the operator\r\n * will be queued for evaluation if and only if the operator has not yet been\r\n * evaluated on the current propagation timestamp.\r\n * @param {Operator} op - The operator to touch.\r\n * @param {object} [options] - Additional options hash.\r\n * @param {boolean} [options.skip] - If true, the operator will\r\n *   be skipped: it will not be evaluated, but its dependents will be.\r\n * @return {Dataflow}\r\n */\nfunction touch(op, options) {\n  const opt = options || NO_OPT;\n  if (this._pulse) {\n    // if in midst of propagation, add to priority queue\n    this._enqueue(op);\n  } else {\n    // otherwise, queue for next propagation\n    this._touched.add(op);\n  }\n  if (opt.skip) op.skip(true);\n  return this;\n}\n\n/**\r\n * Updates the value of the given operator.\r\n * @param {Operator} op - The operator to update.\r\n * @param {*} value - The value to set.\r\n * @param {object} [options] - Additional options hash.\r\n * @param {boolean} [options.force] - If true, the operator will\r\n *   be re-evaluated even if its value has not changed.\r\n * @param {boolean} [options.skip] - If true, the operator will\r\n *   be skipped: it will not be evaluated, but its dependents will be.\r\n * @return {Dataflow}\r\n */\nfunction update(op, value, options) {\n  const opt = options || NO_OPT;\n  if (op.set(value) || opt.force) {\n    this.touch(op, opt);\n  }\n  return this;\n}\n\n/**\r\n * Pulses an operator with a changeset of tuples. If invoked outside of\r\n * a pulse propagation, the pulse will be applied the next time this\r\n * dataflow is run. If invoked in the midst of pulse propagation, the pulse\r\n * will be added to the set of active pulses and will be applied if and\r\n * only if the target operator has not yet been evaluated on the current\r\n * propagation timestamp.\r\n * @param {Operator} op - The operator to pulse.\r\n * @param {ChangeSet} value - The tuple changeset to apply.\r\n * @param {object} [options] - Additional options hash.\r\n * @param {boolean} [options.skip] - If true, the operator will\r\n *   be skipped: it will not be evaluated, but its dependents will be.\r\n * @return {Dataflow}\r\n */\nfunction pulse(op, changeset, options) {\n  this.touch(op, options || NO_OPT);\n  const p = new Pulse(this, this._clock + (this._pulse ? 0 : 1)),\n    t = op.pulse && op.pulse.source || [];\n  p.target = op;\n  this._input[op.id] = changeset.pulse(p, t);\n  return this;\n}\nfunction Heap(cmp) {\n  let nodes = [];\n  return {\n    clear: () => nodes = [],\n    size: () => nodes.length,\n    peek: () => nodes[0],\n    push: x => {\n      nodes.push(x);\n      return siftdown(nodes, 0, nodes.length - 1, cmp);\n    },\n    pop: () => {\n      const last = nodes.pop();\n      let item;\n      if (nodes.length) {\n        item = nodes[0];\n        nodes[0] = last;\n        siftup(nodes, 0, cmp);\n      } else {\n        item = last;\n      }\n      return item;\n    }\n  };\n}\nfunction siftdown(array, start, idx, cmp) {\n  let parent, pidx;\n  const item = array[idx];\n  while (idx > start) {\n    pidx = idx - 1 >> 1;\n    parent = array[pidx];\n    if (cmp(item, parent) < 0) {\n      array[idx] = parent;\n      idx = pidx;\n      continue;\n    }\n    break;\n  }\n  return array[idx] = item;\n}\nfunction siftup(array, idx, cmp) {\n  const start = idx,\n    end = array.length,\n    item = array[idx];\n  let cidx = (idx << 1) + 1,\n    ridx;\n  while (cidx < end) {\n    ridx = cidx + 1;\n    if (ridx < end && cmp(array[cidx], array[ridx]) >= 0) {\n      cidx = ridx;\n    }\n    array[idx] = array[cidx];\n    idx = cidx;\n    cidx = (idx << 1) + 1;\n  }\n  array[idx] = item;\n  return siftdown(array, start, idx, cmp);\n}\n\n/**\r\n * A dataflow graph for reactive processing of data streams.\r\n * @constructor\r\n */\nfunction Dataflow() {\n  this.logger(logger());\n  this.logLevel(Error);\n  this._clock = 0;\n  this._rank = 0;\n  this._locale = defaultLocale();\n  try {\n    this._loader = loader();\n  } catch (e) {\n    // do nothing if loader module is unavailable\n  }\n  this._touched = UniqueList(id);\n  this._input = {};\n  this._pulse = null;\n  this._heap = Heap((a, b) => a.qrank - b.qrank);\n  this._postrun = [];\n}\nfunction logMethod(method) {\n  return function () {\n    return this._log[method].apply(this, arguments);\n  };\n}\nDataflow.prototype = {\n  /**\r\n   * The current timestamp of this dataflow. This value reflects the\r\n   * timestamp of the previous dataflow run. The dataflow is initialized\r\n   * with a stamp value of 0. The initial run of the dataflow will have\r\n   * a timestap of 1, and so on. This value will match the\r\n   * {@link Pulse.stamp} property.\r\n   * @return {number} - The current timestamp value.\r\n   */\n  stamp() {\n    return this._clock;\n  },\n  /**\r\n   * Gets or sets the loader instance to use for data file loading. A\r\n   * loader object must provide a \"load\" method for loading files and a\r\n   * \"sanitize\" method for checking URL/filename validity. Both methods\r\n   * should accept a URI and options hash as arguments, and return a Promise\r\n   * that resolves to the loaded file contents (load) or a hash containing\r\n   * sanitized URI data with the sanitized url assigned to the \"href\" property\r\n   * (sanitize).\r\n   * @param {object} _ - The loader instance to use.\r\n   * @return {object|Dataflow} - If no arguments are provided, returns\r\n   *   the current loader instance. Otherwise returns this Dataflow instance.\r\n   */\n  loader(_) {\n    if (arguments.length) {\n      this._loader = _;\n      return this;\n    } else {\n      return this._loader;\n    }\n  },\n  /**\r\n   * Gets or sets the locale instance to use for formatting and parsing\r\n   * string values. The locale object should be provided by the\r\n   * vega-format library, and include methods such as format, timeFormat,\r\n   * utcFormat, timeParse, and utcParse.\r\n   * @param {object} _ - The locale instance to use.\r\n   * @return {object|Dataflow} - If no arguments are provided, returns\r\n   *   the current locale instance. Otherwise returns this Dataflow instance.\r\n   */\n  locale(_) {\n    if (arguments.length) {\n      this._locale = _;\n      return this;\n    } else {\n      return this._locale;\n    }\n  },\n  /**\r\n   * Get or set the logger instance used to log messages. If no arguments are\r\n   * provided, returns the current logger instance. Otherwise, sets the logger\r\n   * and return this Dataflow instance. Provided loggers must support the full\r\n   * API of logger objects generated by the vega-util logger method. Note that\r\n   * by default the log level of the new logger will be used; use the logLevel\r\n   * method to adjust the log level as needed.\r\n   */\n  logger(logger) {\n    if (arguments.length) {\n      this._log = logger;\n      return this;\n    } else {\n      return this._log;\n    }\n  },\n  /**\r\n   * Logs an error message. By default, logged messages are written to console\r\n   * output. The message will only be logged if the current log level is high\r\n   * enough to permit error messages.\r\n   */\n  error: logMethod('error'),\n  /**\r\n   * Logs a warning message. By default, logged messages are written to console\r\n   * output. The message will only be logged if the current log level is high\r\n   * enough to permit warning messages.\r\n   */\n  warn: logMethod('warn'),\n  /**\r\n   * Logs a information message. By default, logged messages are written to\r\n   * console output. The message will only be logged if the current log level is\r\n   * high enough to permit information messages.\r\n   */\n  info: logMethod('info'),\n  /**\r\n   * Logs a debug message. By default, logged messages are written to console\r\n   * output. The message will only be logged if the current log level is high\r\n   * enough to permit debug messages.\r\n   */\n  debug: logMethod('debug'),\n  /**\r\n   * Get or set the current log level. If an argument is provided, it\r\n   * will be used as the new log level.\r\n   * @param {number} [level] - Should be one of None, Warn, Info\r\n   * @return {number} - The current log level.\r\n   */\n  logLevel: logMethod('level'),\n  /**\r\n   * Empty entry threshold for garbage cleaning. Map data structures will\r\n   * perform cleaning once the number of empty entries exceeds this value.\r\n   */\n  cleanThreshold: 1e4,\n  // OPERATOR REGISTRATION\n  add,\n  connect,\n  rank,\n  rerank,\n  // OPERATOR UPDATES\n  pulse,\n  touch,\n  update,\n  changeset,\n  // DATA LOADING\n  ingest,\n  parse,\n  preload,\n  request,\n  // EVENT HANDLING\n  events,\n  on,\n  // PULSE PROPAGATION\n  evaluate,\n  run,\n  runAsync,\n  runAfter,\n  _enqueue: enqueue,\n  _getPulse: getPulse\n};\n\n/**\r\n * Abstract class for operators that process data tuples.\r\n * Subclasses must provide a {@link transform} method for operator processing.\r\n * @constructor\r\n * @param {*} [init] - The initial value for this operator.\r\n * @param {object} [params] - The parameters for this operator.\r\n * @param {Operator} [source] - The operator from which to receive pulses.\r\n */\nfunction Transform(init, params) {\n  Operator.call(this, init, null, params);\n}\ninherits(Transform, Operator, {\n  /**\r\n   * Overrides {@link Operator.evaluate} for transform operators.\r\n   * Internally, this method calls {@link evaluate} to perform processing.\r\n   * If {@link evaluate} returns a falsy value, the input pulse is returned.\r\n   * This method should NOT be overridden, instead overrride {@link evaluate}.\r\n   * @param {Pulse} pulse - the current dataflow pulse.\r\n   * @return the output pulse for this operator (or StopPropagation)\r\n   */\n  run(pulse) {\n    if (pulse.stamp < this.stamp) return pulse.StopPropagation;\n    let rv;\n    if (this.skip()) {\n      this.skip(false);\n    } else {\n      rv = this.evaluate(pulse);\n    }\n    rv = rv || pulse;\n    if (rv.then) {\n      rv = rv.then(_ => this.pulse = _);\n    } else if (rv !== pulse.StopPropagation) {\n      this.pulse = rv;\n    }\n    return rv;\n  },\n  /**\r\n   * Overrides {@link Operator.evaluate} for transform operators.\r\n   * Marshalls parameter values and then invokes {@link transform}.\r\n   * @param {Pulse} pulse - the current dataflow pulse.\r\n   * @return {Pulse} The output pulse (or StopPropagation). A falsy return\r\n       value (including undefined) will let the input pulse pass through.\r\n  */\n  evaluate(pulse) {\n    const params = this.marshall(pulse.stamp),\n      out = this.transform(params, pulse);\n    params.clear();\n    return out;\n  },\n  /**\r\n   * Process incoming pulses.\r\n   * Subclasses should override this method to implement transforms.\r\n   * @param {Parameters} _ - The operator parameter values.\r\n   * @param {Pulse} pulse - The current dataflow pulse.\r\n   * @return {Pulse} The output pulse (or StopPropagation). A falsy return\r\n   *   value (including undefined) will let the input pulse pass through.\r\n   */\n  transform() {}\n});\nconst transforms = {};\nfunction definition(type) {\n  const t = transform(type);\n  return t && t.Definition || null;\n}\nfunction transform(type) {\n  type = type && type.toLowerCase();\n  return hasOwnProperty(transforms, type) ? transforms[type] : null;\n}\nexport { Dataflow, EventStream, MultiPulse, Operator, Parameters, Pulse, Transform, UniqueList, asyncCallback, changeset, definition, derive, ingest$1 as ingest, isChangeSet, isTuple, rederive, replace, stableCompare, transform, transforms, tupleid };","map":{"version":3,"names":["identity","array","isFunction","constant","isArray","id","error","truthy","debounce","extend","visitArray","inherits","logger","Error","hasOwnProperty","read","responseType","loader","defaultLocale","UniqueList","idFunc","$","list","ids","add","_","push","remove","idx","indexOf","splice","asyncCallback","df","callback","err","TUPLE_ID_KEY","Symbol","TUPLE_ID","isTuple","t","tupleid","setid","ingest$1","datum","Object","data","derive","rederive","d","k","replace","stableCompare","cmp","f","a","b","isChangeSet","v","constructor","changeset","rem","mod","remp","modp","clean","reflow","insert","n","length","i","modify","field","value","m","filter","tuple","encode","set","pulse","tuples","cur","out","forEach","modifies","slice","CACHE","Parameters","defineProperty","writable","prototype","name","index","force","o","modified","arguments","clear","OP_ID","PULSE","NO_PARAMS","SKIP$1","MODIFIED","Operator","init","update","params","react","stamp","rank","qrank","flags","_update","parameters","flag","bit","state","targets","_targets","skip","initonly","argval","_argval","argops","_argops","deps","op","source","Array","marshall","item","detach","evaluate","call","StopPropagation","run","rv","shift","connect","touch","target","sources","targetRank","rerank","STREAM_ID","EventStream","apply","receive","_filter","_apply","stream","consume","_consume","evt","val","trg","preventDefault","stopPropagation","s","merge","throttle","pause","now","Date","delay","e","dataflow","between","active","events","type","send","document","querySelectorAll","addEventListener","parse","format","locale","timeParse","utcParse","ingest","request","url","status","load","context","response","warn","preload","pending","_pending","loadPending","requests","res","done","accept","Promise","SKIP","on","options","fn","onOperator","onStream","opt","func","undefined","updater","_rank","queue","pop","ADD","REM","MOD","ADD_REM","ADD_MOD","ALL","REFLOW","SOURCE","NO_SOURCE","NO_FIELDS","Pulse","fields","materialize","map","visit","addFilter","fork","clone","p","addAll","reuse","src","addF","remF","modF","srcF","cleans","runAfter","changed","len","hash","nomod","some","visitor","sum","MultiPulse","pulses","c","changes","prerun","postrun","async","_pulse","reentrant","_touched","debug","_clock","_enqueue","count","next","_heap","size","_getPulse","then","_input","_postrun","pr","sort","priority","all","cb","runAsync","_running","enqueue","q","getPulse","singlePulse","NO_OPT","Heap","nodes","peek","x","siftdown","last","siftup","start","parent","pidx","end","cidx","ridx","Dataflow","logLevel","_locale","_loader","logMethod","method","_log","info","cleanThreshold","Transform","transform","transforms","definition","Definition","toLowerCase"],"sources":["C:/Users/sanik/Downloads/capstone/MoHSES-Scenario-User-Interface/node_modules/vega-dataflow/build/vega-dataflow.module.js"],"sourcesContent":["import { identity, array, isFunction, constant, isArray, id, error, truthy, debounce, extend, visitArray, inherits, logger, Error, hasOwnProperty } from 'vega-util';\r\nimport { read, responseType, loader } from 'vega-loader';\r\nimport { defaultLocale } from 'vega-format';\r\n\r\nfunction UniqueList(idFunc) {\r\n  const $ = idFunc || identity,\r\n    list = [],\r\n    ids = {};\r\n  list.add = _ => {\r\n    const id = $(_);\r\n    if (!ids[id]) {\r\n      ids[id] = 1;\r\n      list.push(_);\r\n    }\r\n    return list;\r\n  };\r\n  list.remove = _ => {\r\n    const id = $(_);\r\n    if (ids[id]) {\r\n      ids[id] = 0;\r\n      const idx = list.indexOf(_);\r\n      if (idx >= 0) list.splice(idx, 1);\r\n    }\r\n    return list;\r\n  };\r\n  return list;\r\n}\r\n\r\n/**\r\n * Invoke and await a potentially async callback function. If\r\n * an error occurs, trap it and route to Dataflow.error.\r\n * @param {Dataflow} df - The dataflow instance\r\n * @param {function} callback - A callback function to invoke\r\n *   and then await. The dataflow will be passed as the single\r\n *   argument to the function.\r\n */\r\nasync function asyncCallback (df, callback) {\r\n  try {\r\n    await callback(df);\r\n  } catch (err) {\r\n    df.error(err);\r\n  }\r\n}\r\n\r\nconst TUPLE_ID_KEY = Symbol('vega_id');\r\nlet TUPLE_ID = 1;\r\n\r\n/**\r\n * Checks if an input value is a registered tuple.\r\n * @param {*} t - The value to check.\r\n * @return {boolean} True if the input is a tuple, false otherwise.\r\n */\r\nfunction isTuple(t) {\r\n  return !!(t && tupleid(t));\r\n}\r\n\r\n/**\r\n * Returns the id of a tuple.\r\n * @param {object} t - The input tuple.\r\n * @return {*} the tuple id.\r\n */\r\nfunction tupleid(t) {\r\n  return t[TUPLE_ID_KEY];\r\n}\r\n\r\n/**\r\n * Sets the id of a tuple.\r\n * @param {object} t - The input tuple.\r\n * @param {*} id - The id value to set.\r\n * @return {object} the input tuple.\r\n */\r\nfunction setid(t, id) {\r\n  t[TUPLE_ID_KEY] = id;\r\n  return t;\r\n}\r\n\r\n/**\r\n * Ingest an object or value as a data tuple.\r\n * If the input value is an object, an id field will be added to it. For\r\n * efficiency, the input object is modified directly. A copy is not made.\r\n * If the input value is a literal, it will be wrapped in a new object\r\n * instance, with the value accessible as the 'data' property.\r\n * @param datum - The value to ingest.\r\n * @return {object} The ingested data tuple.\r\n */\r\nfunction ingest$1(datum) {\r\n  const t = datum === Object(datum) ? datum : {\r\n    data: datum\r\n  };\r\n  return tupleid(t) ? t : setid(t, TUPLE_ID++);\r\n}\r\n\r\n/**\r\n * Given a source tuple, return a derived copy.\r\n * @param {object} t - The source tuple.\r\n * @return {object} The derived tuple.\r\n */\r\nfunction derive(t) {\r\n  return rederive(t, ingest$1({}));\r\n}\r\n\r\n/**\r\n * Rederive a derived tuple by copying values from the source tuple.\r\n * @param {object} t - The source tuple.\r\n * @param {object} d - The derived tuple.\r\n * @return {object} The derived tuple.\r\n */\r\nfunction rederive(t, d) {\r\n  for (const k in t) d[k] = t[k];\r\n  return d;\r\n}\r\n\r\n/**\r\n * Replace an existing tuple with a new tuple.\r\n * @param {object} t - The existing data tuple.\r\n * @param {object} d - The new tuple that replaces the old.\r\n * @return {object} The new tuple.\r\n */\r\nfunction replace(t, d) {\r\n  return setid(d, tupleid(t));\r\n}\r\n\r\n/**\r\n * Generate an augmented comparator function that provides stable\r\n * sorting by tuple id when the given comparator produces ties.\r\n * @param {function} cmp - The comparator to augment.\r\n * @param {function} [f] - Optional tuple accessor function.\r\n * @return {function} An augmented comparator function.\r\n */\r\nfunction stableCompare(cmp, f) {\r\n  return !cmp ? null : f ? (a, b) => cmp(a, b) || tupleid(f(a)) - tupleid(f(b)) : (a, b) => cmp(a, b) || tupleid(a) - tupleid(b);\r\n}\r\n\r\nfunction isChangeSet(v) {\r\n  return v && v.constructor === changeset;\r\n}\r\nfunction changeset() {\r\n  const add = [],\r\n    // insert tuples\r\n    rem = [],\r\n    // remove tuples\r\n    mod = [],\r\n    // modify tuples\r\n    remp = [],\r\n    // remove by predicate\r\n    modp = []; // modify by predicate\r\n  let clean = null,\r\n    reflow = false;\r\n  return {\r\n    constructor: changeset,\r\n    insert(t) {\r\n      const d = array(t),\r\n        n = d.length;\r\n      for (let i = 0; i < n; ++i) add.push(d[i]);\r\n      return this;\r\n    },\r\n    remove(t) {\r\n      const a = isFunction(t) ? remp : rem,\r\n        d = array(t),\r\n        n = d.length;\r\n      for (let i = 0; i < n; ++i) a.push(d[i]);\r\n      return this;\r\n    },\r\n    modify(t, field, value) {\r\n      const m = {\r\n        field: field,\r\n        value: constant(value)\r\n      };\r\n      if (isFunction(t)) {\r\n        m.filter = t;\r\n        modp.push(m);\r\n      } else {\r\n        m.tuple = t;\r\n        mod.push(m);\r\n      }\r\n      return this;\r\n    },\r\n    encode(t, set) {\r\n      if (isFunction(t)) modp.push({\r\n        filter: t,\r\n        field: set\r\n      });else mod.push({\r\n        tuple: t,\r\n        field: set\r\n      });\r\n      return this;\r\n    },\r\n    clean(value) {\r\n      clean = value;\r\n      return this;\r\n    },\r\n    reflow() {\r\n      reflow = true;\r\n      return this;\r\n    },\r\n    pulse(pulse, tuples) {\r\n      const cur = {},\r\n        out = {};\r\n      let i, n, m, f, t, id;\r\n\r\n      // build lookup table of current tuples\r\n      for (i = 0, n = tuples.length; i < n; ++i) {\r\n        cur[tupleid(tuples[i])] = 1;\r\n      }\r\n\r\n      // process individual tuples to remove\r\n      for (i = 0, n = rem.length; i < n; ++i) {\r\n        t = rem[i];\r\n        cur[tupleid(t)] = -1;\r\n      }\r\n\r\n      // process predicate-based removals\r\n      for (i = 0, n = remp.length; i < n; ++i) {\r\n        f = remp[i];\r\n        tuples.forEach(t => {\r\n          if (f(t)) cur[tupleid(t)] = -1;\r\n        });\r\n      }\r\n\r\n      // process all add tuples\r\n      for (i = 0, n = add.length; i < n; ++i) {\r\n        t = add[i];\r\n        id = tupleid(t);\r\n        if (cur[id]) {\r\n          // tuple already resides in dataset\r\n          // if flagged for both add and remove, cancel\r\n          cur[id] = 1;\r\n        } else {\r\n          // tuple does not reside in dataset, add\r\n          pulse.add.push(ingest$1(add[i]));\r\n        }\r\n      }\r\n\r\n      // populate pulse rem list\r\n      for (i = 0, n = tuples.length; i < n; ++i) {\r\n        t = tuples[i];\r\n        if (cur[tupleid(t)] < 0) pulse.rem.push(t);\r\n      }\r\n\r\n      // modify helper method\r\n      function modify(t, f, v) {\r\n        if (v) {\r\n          t[f] = v(t);\r\n        } else {\r\n          pulse.encode = f;\r\n        }\r\n        if (!reflow) out[tupleid(t)] = t;\r\n      }\r\n\r\n      // process individual tuples to modify\r\n      for (i = 0, n = mod.length; i < n; ++i) {\r\n        m = mod[i];\r\n        t = m.tuple;\r\n        f = m.field;\r\n        id = cur[tupleid(t)];\r\n        if (id > 0) {\r\n          modify(t, f, m.value);\r\n          pulse.modifies(f);\r\n        }\r\n      }\r\n\r\n      // process predicate-based modifications\r\n      for (i = 0, n = modp.length; i < n; ++i) {\r\n        m = modp[i];\r\n        f = m.filter;\r\n        tuples.forEach(t => {\r\n          if (f(t) && cur[tupleid(t)] > 0) {\r\n            modify(t, m.field, m.value);\r\n          }\r\n        });\r\n        pulse.modifies(m.field);\r\n      }\r\n\r\n      // upon reflow request, populate mod with all non-removed tuples\r\n      // otherwise, populate mod with modified tuples only\r\n      if (reflow) {\r\n        pulse.mod = rem.length || remp.length ? tuples.filter(t => cur[tupleid(t)] > 0) : tuples.slice();\r\n      } else {\r\n        for (id in out) pulse.mod.push(out[id]);\r\n      }\r\n\r\n      // set pulse garbage collection request\r\n      if (clean || clean == null && (rem.length || remp.length)) {\r\n        pulse.clean(true);\r\n      }\r\n      return pulse;\r\n    }\r\n  };\r\n}\r\n\r\nconst CACHE = '_:mod:_';\r\n\r\n/**\r\n * Hash that tracks modifications to assigned values.\r\n * Callers *must* use the set method to update values.\r\n */\r\nfunction Parameters() {\r\n  Object.defineProperty(this, CACHE, {\r\n    writable: true,\r\n    value: {}\r\n  });\r\n}\r\nParameters.prototype = {\r\n  /**\r\n   * Set a parameter value. If the parameter value changes, the parameter\r\n   * will be recorded as modified.\r\n   * @param {string} name - The parameter name.\r\n   * @param {number} index - The index into an array-value parameter. Ignored if\r\n   *   the argument is undefined, null or less than zero.\r\n   * @param {*} value - The parameter value to set.\r\n   * @param {boolean} [force=false] - If true, records the parameter as modified\r\n   *   even if the value is unchanged.\r\n   * @return {Parameters} - This parameter object.\r\n   */\r\n  set(name, index, value, force) {\r\n    const o = this,\r\n      v = o[name],\r\n      mod = o[CACHE];\r\n    if (index != null && index >= 0) {\r\n      if (v[index] !== value || force) {\r\n        v[index] = value;\r\n        mod[index + ':' + name] = -1;\r\n        mod[name] = -1;\r\n      }\r\n    } else if (v !== value || force) {\r\n      o[name] = value;\r\n      mod[name] = isArray(value) ? 1 + value.length : -1;\r\n    }\r\n    return o;\r\n  },\r\n  /**\r\n   * Tests if one or more parameters has been modified. If invoked with no\r\n   * arguments, returns true if any parameter value has changed. If the first\r\n   * argument is array, returns trues if any parameter name in the array has\r\n   * changed. Otherwise, tests if the given name and optional array index has\r\n   * changed.\r\n   * @param {string} name - The parameter name to test.\r\n   * @param {number} [index=undefined] - The parameter array index to test.\r\n   * @return {boolean} - Returns true if a queried parameter was modified.\r\n   */\r\n  modified(name, index) {\r\n    const mod = this[CACHE];\r\n    if (!arguments.length) {\r\n      for (const k in mod) {\r\n        if (mod[k]) return true;\r\n      }\r\n      return false;\r\n    } else if (isArray(name)) {\r\n      for (let k = 0; k < name.length; ++k) {\r\n        if (mod[name[k]]) return true;\r\n      }\r\n      return false;\r\n    }\r\n    return index != null && index >= 0 ? index + 1 < mod[name] || !!mod[index + ':' + name] : !!mod[name];\r\n  },\r\n  /**\r\n   * Clears the modification records. After calling this method,\r\n   * all parameters are considered unmodified.\r\n   */\r\n  clear() {\r\n    this[CACHE] = {};\r\n    return this;\r\n  }\r\n};\r\n\r\nlet OP_ID = 0;\r\nconst PULSE = 'pulse',\r\n  NO_PARAMS = new Parameters();\r\n\r\n// Boolean Flags\r\nconst SKIP$1 = 1,\r\n  MODIFIED = 2;\r\n\r\n/**\r\n * An Operator is a processing node in a dataflow graph.\r\n * Each operator stores a value and an optional value update function.\r\n * Operators can accept a hash of named parameters. Parameter values can\r\n * either be direct (JavaScript literals, arrays, objects) or indirect\r\n * (other operators whose values will be pulled dynamically). Operators\r\n * included as parameters will have this operator added as a dependency.\r\n * @constructor\r\n * @param {*} [init] - The initial value for this operator.\r\n * @param {function(object, Pulse)} [update] - An update function. Upon\r\n *   evaluation of this operator, the update function will be invoked and the\r\n *   return value will be used as the new value of this operator.\r\n * @param {object} [params] - The parameters for this operator.\r\n * @param {boolean} [react=true] - Flag indicating if this operator should\r\n *   listen for changes to upstream operators included as parameters.\r\n * @see parameters\r\n */\r\nfunction Operator(init, update, params, react) {\r\n  this.id = ++OP_ID;\r\n  this.value = init;\r\n  this.stamp = -1;\r\n  this.rank = -1;\r\n  this.qrank = -1;\r\n  this.flags = 0;\r\n  if (update) {\r\n    this._update = update;\r\n  }\r\n  if (params) this.parameters(params, react);\r\n}\r\nfunction flag(bit) {\r\n  return function (state) {\r\n    const f = this.flags;\r\n    if (arguments.length === 0) return !!(f & bit);\r\n    this.flags = state ? f | bit : f & ~bit;\r\n    return this;\r\n  };\r\n}\r\nOperator.prototype = {\r\n  /**\r\n   * Returns a list of target operators dependent on this operator.\r\n   * If this list does not exist, it is created and then returned.\r\n   * @return {UniqueList}\r\n   */\r\n  targets() {\r\n    return this._targets || (this._targets = UniqueList(id));\r\n  },\r\n  /**\r\n   * Sets the value of this operator.\r\n   * @param {*} value - the value to set.\r\n   * @return {Number} Returns 1 if the operator value has changed\r\n   *   according to strict equality, returns 0 otherwise.\r\n   */\r\n  set(value) {\r\n    if (this.value !== value) {\r\n      this.value = value;\r\n      return 1;\r\n    } else {\r\n      return 0;\r\n    }\r\n  },\r\n  /**\r\n   * Indicates that operator evaluation should be skipped on the next pulse.\r\n   * This operator will still propagate incoming pulses, but its update function\r\n   * will not be invoked. The skip flag is reset after every pulse, so calling\r\n   * this method will affect processing of the next pulse only.\r\n   */\r\n  skip: flag(SKIP$1),\r\n  /**\r\n   * Indicates that this operator's value has been modified on its most recent\r\n   * pulse. Normally modification is checked via strict equality; however, in\r\n   * some cases it is more efficient to update the internal state of an object.\r\n   * In those cases, the modified flag can be used to trigger propagation. Once\r\n   * set, the modification flag persists across pulses until unset. The flag can\r\n   * be used with the last timestamp to test if a modification is recent.\r\n   */\r\n  modified: flag(MODIFIED),\r\n  /**\r\n   * Sets the parameters for this operator. The parameter values are analyzed for\r\n   * operator instances. If found, this operator will be added as a dependency\r\n   * of the parameterizing operator. Operator values are dynamically marshalled\r\n   * from each operator parameter prior to evaluation. If a parameter value is\r\n   * an array, the array will also be searched for Operator instances. However,\r\n   * the search does not recurse into sub-arrays or object properties.\r\n   * @param {object} params - A hash of operator parameters.\r\n   * @param {boolean} [react=true] - A flag indicating if this operator should\r\n   *   automatically update (react) when parameter values change. In other words,\r\n   *   this flag determines if the operator registers itself as a listener on\r\n   *   any upstream operators included in the parameters.\r\n   * @param {boolean} [initonly=false] - A flag indicating if this operator\r\n   *   should calculate an update only upon its initial evaluation, then\r\n   *   deregister dependencies and suppress all future update invocations.\r\n   * @return {Operator[]} - An array of upstream dependencies.\r\n   */\r\n  parameters(params, react, initonly) {\r\n    react = react !== false;\r\n    const argval = this._argval = this._argval || new Parameters(),\r\n      argops = this._argops = this._argops || [],\r\n      deps = [];\r\n    let name, value, n, i;\r\n    const add = (name, index, value) => {\r\n      if (value instanceof Operator) {\r\n        if (value !== this) {\r\n          if (react) value.targets().add(this);\r\n          deps.push(value);\r\n        }\r\n        argops.push({\r\n          op: value,\r\n          name: name,\r\n          index: index\r\n        });\r\n      } else {\r\n        argval.set(name, index, value);\r\n      }\r\n    };\r\n    for (name in params) {\r\n      value = params[name];\r\n      if (name === PULSE) {\r\n        array(value).forEach(op => {\r\n          if (!(op instanceof Operator)) {\r\n            error('Pulse parameters must be operator instances.');\r\n          } else if (op !== this) {\r\n            op.targets().add(this);\r\n            deps.push(op);\r\n          }\r\n        });\r\n        this.source = value;\r\n      } else if (isArray(value)) {\r\n        argval.set(name, -1, Array(n = value.length));\r\n        for (i = 0; i < n; ++i) add(name, i, value[i]);\r\n      } else {\r\n        add(name, -1, value);\r\n      }\r\n    }\r\n    this.marshall().clear(); // initialize values\r\n    if (initonly) argops.initonly = true;\r\n    return deps;\r\n  },\r\n  /**\r\n   * Internal method for marshalling parameter values.\r\n   * Visits each operator dependency to pull the latest value.\r\n   * @return {Parameters} A Parameters object to pass to the update function.\r\n   */\r\n  marshall(stamp) {\r\n    const argval = this._argval || NO_PARAMS,\r\n      argops = this._argops;\r\n    let item, i, op, mod;\r\n    if (argops) {\r\n      const n = argops.length;\r\n      for (i = 0; i < n; ++i) {\r\n        item = argops[i];\r\n        op = item.op;\r\n        mod = op.modified() && op.stamp === stamp;\r\n        argval.set(item.name, item.index, op.value, mod);\r\n      }\r\n      if (argops.initonly) {\r\n        for (i = 0; i < n; ++i) {\r\n          item = argops[i];\r\n          item.op.targets().remove(this);\r\n        }\r\n        this._argops = null;\r\n        this._update = null;\r\n      }\r\n    }\r\n    return argval;\r\n  },\r\n  /**\r\n   * Detach this operator from the dataflow.\r\n   * Unregisters listeners on upstream dependencies.\r\n   */\r\n  detach() {\r\n    const argops = this._argops;\r\n    let i, n, item, op;\r\n    if (argops) {\r\n      for (i = 0, n = argops.length; i < n; ++i) {\r\n        item = argops[i];\r\n        op = item.op;\r\n        if (op._targets) {\r\n          op._targets.remove(this);\r\n        }\r\n      }\r\n    }\r\n\r\n    // remove references to the source and pulse object,\r\n    // if present, to prevent memory leaks of old data.\r\n    this.pulse = null;\r\n    this.source = null;\r\n  },\r\n  /**\r\n   * Delegate method to perform operator processing.\r\n   * Subclasses can override this method to perform custom processing.\r\n   * By default, it marshalls parameters and calls the update function\r\n   * if that function is defined. If the update function does not\r\n   * change the operator value then StopPropagation is returned.\r\n   * If no update function is defined, this method does nothing.\r\n   * @param {Pulse} pulse - the current dataflow pulse.\r\n   * @return The output pulse or StopPropagation. A falsy return value\r\n   *   (including undefined) will let the input pulse pass through.\r\n   */\r\n  evaluate(pulse) {\r\n    const update = this._update;\r\n    if (update) {\r\n      const params = this.marshall(pulse.stamp),\r\n        v = update.call(this, params, pulse);\r\n      params.clear();\r\n      if (v !== this.value) {\r\n        this.value = v;\r\n      } else if (!this.modified()) {\r\n        return pulse.StopPropagation;\r\n      }\r\n    }\r\n  },\r\n  /**\r\n   * Run this operator for the current pulse. If this operator has already\r\n   * been run at (or after) the pulse timestamp, returns StopPropagation.\r\n   * Internally, this method calls {@link evaluate} to perform processing.\r\n   * If {@link evaluate} returns a falsy value, the input pulse is returned.\r\n   * This method should NOT be overridden, instead overrride {@link evaluate}.\r\n   * @param {Pulse} pulse - the current dataflow pulse.\r\n   * @return the output pulse for this operator (or StopPropagation)\r\n   */\r\n  run(pulse) {\r\n    if (pulse.stamp < this.stamp) return pulse.StopPropagation;\r\n    let rv;\r\n    if (this.skip()) {\r\n      this.skip(false);\r\n      rv = 0;\r\n    } else {\r\n      rv = this.evaluate(pulse);\r\n    }\r\n    return this.pulse = rv || pulse;\r\n  }\r\n};\r\n\r\n/**\r\n * Add an operator to the dataflow graph. This function accepts a\r\n * variety of input argument types. The basic signature supports an\r\n * initial value, update function and parameters. If the first parameter\r\n * is an Operator instance, it will be added directly. If it is a\r\n * constructor for an Operator subclass, a new instance will be instantiated.\r\n * Otherwise, if the first parameter is a function instance, it will be used\r\n * as the update function and a null initial value is assumed.\r\n * @param {*} init - One of: the operator to add, the initial value of\r\n *   the operator, an operator class to instantiate, or an update function.\r\n * @param {function} [update] - The operator update function.\r\n * @param {object} [params] - The operator parameters.\r\n * @param {boolean} [react=true] - Flag indicating if this operator should\r\n *   listen for changes to upstream operators included as parameters.\r\n * @return {Operator} - The added operator.\r\n */\r\nfunction add (init, update, params, react) {\r\n  let shift = 1,\r\n    op;\r\n  if (init instanceof Operator) {\r\n    op = init;\r\n  } else if (init && init.prototype instanceof Operator) {\r\n    op = new init();\r\n  } else if (isFunction(init)) {\r\n    op = new Operator(null, init);\r\n  } else {\r\n    shift = 0;\r\n    op = new Operator(init, update);\r\n  }\r\n  this.rank(op);\r\n  if (shift) {\r\n    react = params;\r\n    params = update;\r\n  }\r\n  if (params) this.connect(op, op.parameters(params, react));\r\n  this.touch(op);\r\n  return op;\r\n}\r\n\r\n/**\r\n * Connect a target operator as a dependent of source operators.\r\n * If necessary, this method will rerank the target operator and its\r\n * dependents to ensure propagation proceeds in a topologically sorted order.\r\n * @param {Operator} target - The target operator.\r\n * @param {Array<Operator>} - The source operators that should propagate\r\n *   to the target operator.\r\n */\r\nfunction connect (target, sources) {\r\n  const targetRank = target.rank,\r\n    n = sources.length;\r\n  for (let i = 0; i < n; ++i) {\r\n    if (targetRank < sources[i].rank) {\r\n      this.rerank(target);\r\n      return;\r\n    }\r\n  }\r\n}\r\n\r\nlet STREAM_ID = 0;\r\n\r\n/**\r\n * Models an event stream.\r\n * @constructor\r\n * @param {function(Object, number): boolean} [filter] - Filter predicate.\r\n *   Events pass through when truthy, events are suppressed when falsy.\r\n * @param {function(Object): *} [apply] - Applied to input events to produce\r\n *   new event values.\r\n * @param {function(Object)} [receive] - Event callback function to invoke\r\n *   upon receipt of a new event. Use to override standard event processing.\r\n */\r\nfunction EventStream(filter, apply, receive) {\r\n  this.id = ++STREAM_ID;\r\n  this.value = null;\r\n  if (receive) this.receive = receive;\r\n  if (filter) this._filter = filter;\r\n  if (apply) this._apply = apply;\r\n}\r\n\r\n/**\r\n * Creates a new event stream instance with the provided\r\n * (optional) filter, apply and receive functions.\r\n * @param {function(Object, number): boolean} [filter] - Filter predicate.\r\n *   Events pass through when truthy, events are suppressed when falsy.\r\n * @param {function(Object): *} [apply] - Applied to input events to produce\r\n *   new event values.\r\n * @see EventStream\r\n */\r\nfunction stream(filter, apply, receive) {\r\n  return new EventStream(filter, apply, receive);\r\n}\r\nEventStream.prototype = {\r\n  _filter: truthy,\r\n  _apply: identity,\r\n  targets() {\r\n    return this._targets || (this._targets = UniqueList(id));\r\n  },\r\n  consume(_) {\r\n    if (!arguments.length) return !!this._consume;\r\n    this._consume = !!_;\r\n    return this;\r\n  },\r\n  receive(evt) {\r\n    if (this._filter(evt)) {\r\n      const val = this.value = this._apply(evt),\r\n        trg = this._targets,\r\n        n = trg ? trg.length : 0;\r\n      for (let i = 0; i < n; ++i) trg[i].receive(val);\r\n      if (this._consume) {\r\n        evt.preventDefault();\r\n        evt.stopPropagation();\r\n      }\r\n    }\r\n  },\r\n  filter(filter) {\r\n    const s = stream(filter);\r\n    this.targets().add(s);\r\n    return s;\r\n  },\r\n  apply(apply) {\r\n    const s = stream(null, apply);\r\n    this.targets().add(s);\r\n    return s;\r\n  },\r\n  merge() {\r\n    const s = stream();\r\n    this.targets().add(s);\r\n    for (let i = 0, n = arguments.length; i < n; ++i) {\r\n      arguments[i].targets().add(s);\r\n    }\r\n    return s;\r\n  },\r\n  throttle(pause) {\r\n    let t = -1;\r\n    return this.filter(() => {\r\n      const now = Date.now();\r\n      if (now - t > pause) {\r\n        t = now;\r\n        return 1;\r\n      } else {\r\n        return 0;\r\n      }\r\n    });\r\n  },\r\n  debounce(delay) {\r\n    const s = stream();\r\n    this.targets().add(stream(null, null, debounce(delay, e => {\r\n      const df = e.dataflow;\r\n      s.receive(e);\r\n      if (df && df.run) df.run();\r\n    })));\r\n    return s;\r\n  },\r\n  between(a, b) {\r\n    let active = false;\r\n    a.targets().add(stream(null, null, () => active = true));\r\n    b.targets().add(stream(null, null, () => active = false));\r\n    return this.filter(() => active);\r\n  },\r\n  detach() {\r\n    // ensures compatibility with operators (#2753)\r\n    // remove references to other streams and filter functions that may\r\n    // be bound to subcontexts that need to be garbage collected.\r\n    this._filter = truthy;\r\n    this._targets = null;\r\n  }\r\n};\r\n\r\n/**\r\n * Create a new event stream from an event source.\r\n * @param {object} source - The event source to monitor. The input must\r\n *  support the addEventListener method.\r\n * @param {string} type - The event type.\r\n * @param {function(object): boolean} [filter] - Event filter function.\r\n * @param {function(object): *} [apply] - Event application function.\r\n *   If provided, this function will be invoked and the result will be\r\n *   used as the downstream event value.\r\n * @return {EventStream}\r\n */\r\nfunction events (source, type, filter, apply) {\r\n  const df = this,\r\n    s = stream(filter, apply),\r\n    send = function (e) {\r\n      e.dataflow = df;\r\n      try {\r\n        s.receive(e);\r\n      } catch (error) {\r\n        df.error(error);\r\n      } finally {\r\n        df.run();\r\n      }\r\n    };\r\n  let sources;\r\n  if (typeof source === 'string' && typeof document !== 'undefined') {\r\n    sources = document.querySelectorAll(source);\r\n  } else {\r\n    sources = array(source);\r\n  }\r\n  const n = sources.length;\r\n  for (let i = 0; i < n; ++i) {\r\n    sources[i].addEventListener(type, send);\r\n  }\r\n  return s;\r\n}\r\n\r\nfunction parse(data, format) {\r\n  const locale = this.locale();\r\n  return read(data, format, locale.timeParse, locale.utcParse);\r\n}\r\n\r\n/**\r\n * Ingests new data into the dataflow. First parses the data using the\r\n * vega-loader read method, then pulses a changeset to the target operator.\r\n * @param {Operator} target - The Operator to target with ingested data,\r\n *   typically a Collect transform instance.\r\n * @param {*} data - The input data, prior to parsing. For JSON this may\r\n *   be a string or an object. For CSV, TSV, etc should be a string.\r\n * @param {object} format - The data format description for parsing\r\n *   loaded data. This object is passed to the vega-loader read method.\r\n * @returns {Dataflow}\r\n */\r\nfunction ingest(target, data, format) {\r\n  data = this.parse(data, format);\r\n  return this.pulse(target, this.changeset().insert(data));\r\n}\r\n\r\n/**\r\n * Request data from an external source, parse it, and return a Promise.\r\n * @param {string} url - The URL from which to load the data. This string\r\n *   is passed to the vega-loader load method.\r\n * @param {object} [format] - The data format description for parsing\r\n *   loaded data. This object is passed to the vega-loader read method.\r\n * @return {Promise} A Promise that resolves upon completion of the request.\r\n *   The resolved object contains the following properties:\r\n *   - data: an array of parsed data (or null upon error)\r\n *   - status: a code for success (0), load fail (-1), or parse fail (-2)\r\n */\r\nasync function request(url, format) {\r\n  const df = this;\r\n  let status = 0,\r\n    data;\r\n  try {\r\n    data = await df.loader().load(url, {\r\n      context: 'dataflow',\r\n      response: responseType(format && format.type)\r\n    });\r\n    try {\r\n      data = df.parse(data, format);\r\n    } catch (err) {\r\n      status = -2;\r\n      df.warn('Data ingestion failed', url, err);\r\n    }\r\n  } catch (err) {\r\n    status = -1;\r\n    df.warn('Loading failed', url, err);\r\n  }\r\n  return {\r\n    data,\r\n    status\r\n  };\r\n}\r\nasync function preload(target, url, format) {\r\n  const df = this,\r\n    pending = df._pending || loadPending(df);\r\n  pending.requests += 1;\r\n  const res = await df.request(url, format);\r\n  df.pulse(target, df.changeset().remove(truthy).insert(res.data || []));\r\n  pending.done();\r\n  return res;\r\n}\r\nfunction loadPending(df) {\r\n  let accept;\r\n  const pending = new Promise(a => accept = a);\r\n  pending.requests = 0;\r\n  pending.done = () => {\r\n    if (--pending.requests === 0) {\r\n      df._pending = null;\r\n      accept(df);\r\n    }\r\n  };\r\n  return df._pending = pending;\r\n}\r\n\r\nconst SKIP = {\r\n  skip: true\r\n};\r\n\r\n/**\r\n * Perform operator updates in response to events. Applies an\r\n * update function to compute a new operator value. If the update function\r\n * returns a {@link ChangeSet}, the operator will be pulsed with those tuple\r\n * changes. Otherwise, the operator value will be updated to the return value.\r\n * @param {EventStream|Operator} source - The event source to react to.\r\n *   This argument can be either an EventStream or an Operator.\r\n * @param {Operator|function(object):Operator} target - The operator to update.\r\n *   This argument can either be an Operator instance or (if the source\r\n *   argument is an EventStream), a function that accepts an event object as\r\n *   input and returns an Operator to target.\r\n * @param {function(Parameters,Event): *} [update] - Optional update function\r\n *   to compute the new operator value, or a literal value to set. Update\r\n *   functions expect to receive a parameter object and event as arguments.\r\n *   This function can either return a new operator value or (if the source\r\n *   argument is an EventStream) a {@link ChangeSet} instance to pulse\r\n *   the target operator with tuple changes.\r\n * @param {object} [params] - The update function parameters.\r\n * @param {object} [options] - Additional options hash. If not overridden,\r\n *   updated operators will be skipped by default.\r\n * @param {boolean} [options.skip] - If true, the operator will\r\n *  be skipped: it will not be evaluated, but its dependents will be.\r\n * @param {boolean} [options.force] - If true, the operator will\r\n *   be re-evaluated even if its value has not changed.\r\n * @return {Dataflow}\r\n */\r\nfunction on (source, target, update, params, options) {\r\n  const fn = source instanceof Operator ? onOperator : onStream;\r\n  fn(this, source, target, update, params, options);\r\n  return this;\r\n}\r\nfunction onStream(df, stream, target, update, params, options) {\r\n  const opt = extend({}, options, SKIP);\r\n  let func, op;\r\n  if (!isFunction(target)) target = constant(target);\r\n  if (update === undefined) {\r\n    func = e => df.touch(target(e));\r\n  } else if (isFunction(update)) {\r\n    op = new Operator(null, update, params, false);\r\n    func = e => {\r\n      op.evaluate(e);\r\n      const t = target(e),\r\n        v = op.value;\r\n      isChangeSet(v) ? df.pulse(t, v, options) : df.update(t, v, opt);\r\n    };\r\n  } else {\r\n    func = e => df.update(target(e), update, opt);\r\n  }\r\n  stream.apply(func);\r\n}\r\nfunction onOperator(df, source, target, update, params, options) {\r\n  if (update === undefined) {\r\n    source.targets().add(target);\r\n  } else {\r\n    const opt = options || {},\r\n      op = new Operator(null, updater(target, update), params, false);\r\n    op.modified(opt.force);\r\n    op.rank = source.rank; // immediately follow source\r\n    source.targets().add(op); // add dependency\r\n\r\n    if (target) {\r\n      op.skip(true); // skip first invocation\r\n      op.value = target.value; // initialize value\r\n      op.targets().add(target); // chain dependencies\r\n      df.connect(target, [op]); // rerank as needed, #1672\r\n    }\r\n  }\r\n}\r\n\r\nfunction updater(target, update) {\r\n  update = isFunction(update) ? update : constant(update);\r\n  return target ? function (_, pulse) {\r\n    const value = update(_, pulse);\r\n    if (!target.skip()) {\r\n      target.skip(value !== this.value).value = value;\r\n    }\r\n    return value;\r\n  } : update;\r\n}\r\n\r\n/**\r\n * Assigns a rank to an operator. Ranks are assigned in increasing order\r\n * by incrementing an internal rank counter.\r\n * @param {Operator} op - The operator to assign a rank.\r\n */\r\nfunction rank(op) {\r\n  op.rank = ++this._rank;\r\n}\r\n\r\n/**\r\n * Re-ranks an operator and all downstream target dependencies. This\r\n * is necessary when upstream dependencies of higher rank are added to\r\n * a target operator.\r\n * @param {Operator} op - The operator to re-rank.\r\n */\r\nfunction rerank(op) {\r\n  const queue = [op];\r\n  let cur, list, i;\r\n  while (queue.length) {\r\n    this.rank(cur = queue.pop());\r\n    if (list = cur._targets) {\r\n      for (i = list.length; --i >= 0;) {\r\n        queue.push(cur = list[i]);\r\n        if (cur === op) error('Cycle detected in dataflow graph.');\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Sentinel value indicating pulse propagation should stop.\r\n */\r\nconst StopPropagation = {};\r\n\r\n// Pulse visit type flags\r\nconst ADD = 1 << 0,\r\n  REM = 1 << 1,\r\n  MOD = 1 << 2,\r\n  ADD_REM = ADD | REM,\r\n  ADD_MOD = ADD | MOD,\r\n  ALL = ADD | REM | MOD,\r\n  REFLOW = 1 << 3,\r\n  SOURCE = 1 << 4,\r\n  NO_SOURCE = 1 << 5,\r\n  NO_FIELDS = 1 << 6;\r\n\r\n/**\r\n * A Pulse enables inter-operator communication during a run of the\r\n * dataflow graph. In addition to the current timestamp, a pulse may also\r\n * contain a change-set of added, removed or modified data tuples, as well as\r\n * a pointer to a full backing data source. Tuple change sets may not\r\n * be fully materialized; for example, to prevent needless array creation\r\n * a change set may include larger arrays and corresponding filter functions.\r\n * The pulse provides a {@link visit} method to enable proper and efficient\r\n * iteration over requested data tuples.\r\n *\r\n * In addition, each pulse can track modification flags for data tuple fields.\r\n * Responsible transform operators should call the {@link modifies} method to\r\n * indicate changes to data fields. The {@link modified} method enables\r\n * querying of this modification state.\r\n *\r\n * @constructor\r\n * @param {Dataflow} dataflow - The backing dataflow instance.\r\n * @param {number} stamp - The current propagation timestamp.\r\n * @param {string} [encode] - An optional encoding set name, which is then\r\n *   accessible as Pulse.encode. Operators can respond to (or ignore) this\r\n *   setting as appropriate. This parameter can be used in conjunction with\r\n *   the Encode transform in the vega-encode module.\r\n */\r\nfunction Pulse(dataflow, stamp, encode) {\r\n  this.dataflow = dataflow;\r\n  this.stamp = stamp == null ? -1 : stamp;\r\n  this.add = [];\r\n  this.rem = [];\r\n  this.mod = [];\r\n  this.fields = null;\r\n  this.encode = encode || null;\r\n}\r\nfunction materialize(data, filter) {\r\n  const out = [];\r\n  visitArray(data, filter, _ => out.push(_));\r\n  return out;\r\n}\r\nfunction filter(pulse, flags) {\r\n  const map = {};\r\n  pulse.visit(flags, t => {\r\n    map[tupleid(t)] = 1;\r\n  });\r\n  return t => map[tupleid(t)] ? null : t;\r\n}\r\nfunction addFilter(a, b) {\r\n  return a ? (t, i) => a(t, i) && b(t, i) : b;\r\n}\r\nPulse.prototype = {\r\n  /**\r\n   * Sentinel value indicating pulse propagation should stop.\r\n   */\r\n  StopPropagation,\r\n  /**\r\n   * Boolean flag indicating ADD (added) tuples.\r\n   */\r\n  ADD,\r\n  /**\r\n   * Boolean flag indicating REM (removed) tuples.\r\n   */\r\n  REM,\r\n  /**\r\n   * Boolean flag indicating MOD (modified) tuples.\r\n   */\r\n  MOD,\r\n  /**\r\n   * Boolean flag indicating ADD (added) and REM (removed) tuples.\r\n   */\r\n  ADD_REM,\r\n  /**\r\n   * Boolean flag indicating ADD (added) and MOD (modified) tuples.\r\n   */\r\n  ADD_MOD,\r\n  /**\r\n   * Boolean flag indicating ADD, REM and MOD tuples.\r\n   */\r\n  ALL,\r\n  /**\r\n   * Boolean flag indicating all tuples in a data source\r\n   * except for the ADD, REM and MOD tuples.\r\n   */\r\n  REFLOW,\r\n  /**\r\n   * Boolean flag indicating a 'pass-through' to a\r\n   * backing data source, ignoring ADD, REM and MOD tuples.\r\n   */\r\n  SOURCE,\r\n  /**\r\n   * Boolean flag indicating that source data should be\r\n   * suppressed when creating a forked pulse.\r\n   */\r\n  NO_SOURCE,\r\n  /**\r\n   * Boolean flag indicating that field modifications should be\r\n   * suppressed when creating a forked pulse.\r\n   */\r\n  NO_FIELDS,\r\n  /**\r\n   * Creates a new pulse based on the values of this pulse.\r\n   * The dataflow, time stamp and field modification values are copied over.\r\n   * By default, new empty ADD, REM and MOD arrays are created.\r\n   * @param {number} flags - Integer of boolean flags indicating which (if any)\r\n   *   tuple arrays should be copied to the new pulse. The supported flag values\r\n   *   are ADD, REM and MOD. Array references are copied directly: new array\r\n   *   instances are not created.\r\n   * @return {Pulse} - The forked pulse instance.\r\n   * @see init\r\n   */\r\n  fork(flags) {\r\n    return new Pulse(this.dataflow).init(this, flags);\r\n  },\r\n  /**\r\n   * Creates a copy of this pulse with new materialized array\r\n   * instances for the ADD, REM, MOD, and SOURCE arrays.\r\n   * The dataflow, time stamp and field modification values are copied over.\r\n   * @return {Pulse} - The cloned pulse instance.\r\n   * @see init\r\n   */\r\n  clone() {\r\n    const p = this.fork(ALL);\r\n    p.add = p.add.slice();\r\n    p.rem = p.rem.slice();\r\n    p.mod = p.mod.slice();\r\n    if (p.source) p.source = p.source.slice();\r\n    return p.materialize(ALL | SOURCE);\r\n  },\r\n  /**\r\n   * Returns a pulse that adds all tuples from a backing source. This is\r\n   * useful for cases where operators are added to a dataflow after an\r\n   * upstream data pipeline has already been processed, ensuring that\r\n   * new operators can observe all tuples within a stream.\r\n   * @return {Pulse} - A pulse instance with all source tuples included\r\n   *   in the add array. If the current pulse already has all source\r\n   *   tuples in its add array, it is returned directly. If the current\r\n   *   pulse does not have a backing source, it is returned directly.\r\n   */\r\n  addAll() {\r\n    let p = this;\r\n    const reuse = !p.source || p.add === p.rem // special case for indexed set (e.g., crossfilter)\r\n    || !p.rem.length && p.source.length === p.add.length;\r\n    if (reuse) {\r\n      return p;\r\n    } else {\r\n      p = new Pulse(this.dataflow).init(this);\r\n      p.add = p.source;\r\n      p.rem = []; // new operators can ignore rem #2769\r\n      return p;\r\n    }\r\n  },\r\n  /**\r\n   * Initialize this pulse based on the values of another pulse. This method\r\n   * is used internally by {@link fork} to initialize a new forked tuple.\r\n   * The dataflow, time stamp and field modification values are copied over.\r\n   * By default, new empty ADD, REM and MOD arrays are created.\r\n   * @param {Pulse} src - The source pulse to copy from.\r\n   * @param {number} flags - Integer of boolean flags indicating which (if any)\r\n   *   tuple arrays should be copied to the new pulse. The supported flag values\r\n   *   are ADD, REM and MOD. Array references are copied directly: new array\r\n   *   instances are not created. By default, source data arrays are copied\r\n   *   to the new pulse. Use the NO_SOURCE flag to enforce a null source.\r\n   * @return {Pulse} - Returns this Pulse instance.\r\n   */\r\n  init(src, flags) {\r\n    const p = this;\r\n    p.stamp = src.stamp;\r\n    p.encode = src.encode;\r\n    if (src.fields && !(flags & NO_FIELDS)) {\r\n      p.fields = src.fields;\r\n    }\r\n    if (flags & ADD) {\r\n      p.addF = src.addF;\r\n      p.add = src.add;\r\n    } else {\r\n      p.addF = null;\r\n      p.add = [];\r\n    }\r\n    if (flags & REM) {\r\n      p.remF = src.remF;\r\n      p.rem = src.rem;\r\n    } else {\r\n      p.remF = null;\r\n      p.rem = [];\r\n    }\r\n    if (flags & MOD) {\r\n      p.modF = src.modF;\r\n      p.mod = src.mod;\r\n    } else {\r\n      p.modF = null;\r\n      p.mod = [];\r\n    }\r\n    if (flags & NO_SOURCE) {\r\n      p.srcF = null;\r\n      p.source = null;\r\n    } else {\r\n      p.srcF = src.srcF;\r\n      p.source = src.source;\r\n      if (src.cleans) p.cleans = src.cleans;\r\n    }\r\n    return p;\r\n  },\r\n  /**\r\n   * Schedules a function to run after pulse propagation completes.\r\n   * @param {function} func - The function to run.\r\n   */\r\n  runAfter(func) {\r\n    this.dataflow.runAfter(func);\r\n  },\r\n  /**\r\n   * Indicates if tuples have been added, removed or modified.\r\n   * @param {number} [flags] - The tuple types (ADD, REM or MOD) to query.\r\n   *   Defaults to ALL, returning true if any tuple type has changed.\r\n   * @return {boolean} - Returns true if one or more queried tuple types have\r\n   *   changed, false otherwise.\r\n   */\r\n  changed(flags) {\r\n    const f = flags || ALL;\r\n    return f & ADD && this.add.length || f & REM && this.rem.length || f & MOD && this.mod.length;\r\n  },\r\n  /**\r\n   * Forces a \"reflow\" of tuple values, such that all tuples in the backing\r\n   * source are added to the MOD set, unless already present in the ADD set.\r\n   * @param {boolean} [fork=false] - If true, returns a forked copy of this\r\n   *   pulse, and invokes reflow on that derived pulse.\r\n   * @return {Pulse} - The reflowed pulse instance.\r\n   */\r\n  reflow(fork) {\r\n    if (fork) return this.fork(ALL).reflow();\r\n    const len = this.add.length,\r\n      src = this.source && this.source.length;\r\n    if (src && src !== len) {\r\n      this.mod = this.source;\r\n      if (len) this.filter(MOD, filter(this, ADD));\r\n    }\r\n    return this;\r\n  },\r\n  /**\r\n   * Get/set metadata to pulse requesting garbage collection\r\n   * to reclaim currently unused resources.\r\n   */\r\n  clean(value) {\r\n    if (arguments.length) {\r\n      this.cleans = !!value;\r\n      return this;\r\n    } else {\r\n      return this.cleans;\r\n    }\r\n  },\r\n  /**\r\n   * Marks one or more data field names as modified to assist dependency\r\n   * tracking and incremental processing by transform operators.\r\n   * @param {string|Array<string>} _ - The field(s) to mark as modified.\r\n   * @return {Pulse} - This pulse instance.\r\n   */\r\n  modifies(_) {\r\n    const hash = this.fields || (this.fields = {});\r\n    if (isArray(_)) {\r\n      _.forEach(f => hash[f] = true);\r\n    } else {\r\n      hash[_] = true;\r\n    }\r\n    return this;\r\n  },\r\n  /**\r\n   * Checks if one or more data fields have been modified during this pulse\r\n   * propagation timestamp.\r\n   * @param {string|Array<string>} _ - The field(s) to check for modified.\r\n   * @param {boolean} nomod - If true, will check the modified flag even if\r\n   *   no mod tuples exist. If false (default), mod tuples must be present.\r\n   * @return {boolean} - Returns true if any of the provided fields has been\r\n   *   marked as modified, false otherwise.\r\n   */\r\n  modified(_, nomod) {\r\n    const fields = this.fields;\r\n    return !((nomod || this.mod.length) && fields) ? false : !arguments.length ? !!fields : isArray(_) ? _.some(f => fields[f]) : fields[_];\r\n  },\r\n  /**\r\n   * Adds a filter function to one more tuple sets. Filters are applied to\r\n   * backing tuple arrays, to determine the actual set of tuples considered\r\n   * added, removed or modified. They can be used to delay materialization of\r\n   * a tuple set in order to avoid expensive array copies. In addition, the\r\n   * filter functions can serve as value transformers: unlike standard predicate\r\n   * function (which return boolean values), Pulse filters should return the\r\n   * actual tuple value to process. If a tuple set is already filtered, the\r\n   * new filter function will be appended into a conjuntive ('and') query.\r\n   * @param {number} flags - Flags indicating the tuple set(s) to filter.\r\n   * @param {function(*):object} filter - Filter function that will be applied\r\n   *   to the tuple set array, and should return a data tuple if the value\r\n   *   should be included in the tuple set, and falsy (or null) otherwise.\r\n   * @return {Pulse} - Returns this pulse instance.\r\n   */\r\n  filter(flags, filter) {\r\n    const p = this;\r\n    if (flags & ADD) p.addF = addFilter(p.addF, filter);\r\n    if (flags & REM) p.remF = addFilter(p.remF, filter);\r\n    if (flags & MOD) p.modF = addFilter(p.modF, filter);\r\n    if (flags & SOURCE) p.srcF = addFilter(p.srcF, filter);\r\n    return p;\r\n  },\r\n  /**\r\n   * Materialize one or more tuple sets in this pulse. If the tuple set(s) have\r\n   * a registered filter function, it will be applied and the tuple set(s) will\r\n   * be replaced with materialized tuple arrays.\r\n   * @param {number} flags - Flags indicating the tuple set(s) to materialize.\r\n   * @return {Pulse} - Returns this pulse instance.\r\n   */\r\n  materialize(flags) {\r\n    flags = flags || ALL;\r\n    const p = this;\r\n    if (flags & ADD && p.addF) {\r\n      p.add = materialize(p.add, p.addF);\r\n      p.addF = null;\r\n    }\r\n    if (flags & REM && p.remF) {\r\n      p.rem = materialize(p.rem, p.remF);\r\n      p.remF = null;\r\n    }\r\n    if (flags & MOD && p.modF) {\r\n      p.mod = materialize(p.mod, p.modF);\r\n      p.modF = null;\r\n    }\r\n    if (flags & SOURCE && p.srcF) {\r\n      p.source = p.source.filter(p.srcF);\r\n      p.srcF = null;\r\n    }\r\n    return p;\r\n  },\r\n  /**\r\n   * Visit one or more tuple sets in this pulse.\r\n   * @param {number} flags - Flags indicating the tuple set(s) to visit.\r\n   *   Legal values are ADD, REM, MOD and SOURCE (if a backing data source\r\n   *   has been set).\r\n   * @param {function(object):*} - Visitor function invoked per-tuple.\r\n   * @return {Pulse} - Returns this pulse instance.\r\n   */\r\n  visit(flags, visitor) {\r\n    const p = this,\r\n      v = visitor;\r\n    if (flags & SOURCE) {\r\n      visitArray(p.source, p.srcF, v);\r\n      return p;\r\n    }\r\n    if (flags & ADD) visitArray(p.add, p.addF, v);\r\n    if (flags & REM) visitArray(p.rem, p.remF, v);\r\n    if (flags & MOD) visitArray(p.mod, p.modF, v);\r\n    const src = p.source;\r\n    if (flags & REFLOW && src) {\r\n      const sum = p.add.length + p.mod.length;\r\n      if (sum === src.length) ; else if (sum) {\r\n        visitArray(src, filter(p, ADD_MOD), v);\r\n      } else {\r\n        // if no add/rem/mod tuples, visit source\r\n        visitArray(src, p.srcF, v);\r\n      }\r\n    }\r\n    return p;\r\n  }\r\n};\r\n\r\n/**\r\n * Represents a set of multiple pulses. Used as input for operators\r\n * that accept multiple pulses at a time. Contained pulses are\r\n * accessible via the public \"pulses\" array property. This pulse doe\r\n * not carry added, removed or modified tuples directly. However,\r\n * the visit method can be used to traverse all such tuples contained\r\n * in sub-pulses with a timestamp matching this parent multi-pulse.\r\n * @constructor\r\n * @param {Dataflow} dataflow - The backing dataflow instance.\r\n * @param {number} stamp - The timestamp.\r\n * @param {Array<Pulse>} pulses - The sub-pulses for this multi-pulse.\r\n */\r\nfunction MultiPulse(dataflow, stamp, pulses, encode) {\r\n  const p = this;\r\n  let c = 0;\r\n  this.dataflow = dataflow;\r\n  this.stamp = stamp;\r\n  this.fields = null;\r\n  this.encode = encode || null;\r\n  this.pulses = pulses;\r\n  for (const pulse of pulses) {\r\n    if (pulse.stamp !== stamp) continue;\r\n    if (pulse.fields) {\r\n      const hash = p.fields || (p.fields = {});\r\n      for (const f in pulse.fields) {\r\n        hash[f] = 1;\r\n      }\r\n    }\r\n    if (pulse.changed(p.ADD)) c |= p.ADD;\r\n    if (pulse.changed(p.REM)) c |= p.REM;\r\n    if (pulse.changed(p.MOD)) c |= p.MOD;\r\n  }\r\n  this.changes = c;\r\n}\r\ninherits(MultiPulse, Pulse, {\r\n  /**\r\n   * Creates a new pulse based on the values of this pulse.\r\n   * The dataflow, time stamp and field modification values are copied over.\r\n   * @return {Pulse}\r\n   */\r\n  fork(flags) {\r\n    const p = new Pulse(this.dataflow).init(this, flags & this.NO_FIELDS);\r\n    if (flags !== undefined) {\r\n      if (flags & p.ADD) this.visit(p.ADD, t => p.add.push(t));\r\n      if (flags & p.REM) this.visit(p.REM, t => p.rem.push(t));\r\n      if (flags & p.MOD) this.visit(p.MOD, t => p.mod.push(t));\r\n    }\r\n    return p;\r\n  },\r\n  changed(flags) {\r\n    return this.changes & flags;\r\n  },\r\n  modified(_) {\r\n    const p = this,\r\n      fields = p.fields;\r\n    return !(fields && p.changes & p.MOD) ? 0 : isArray(_) ? _.some(f => fields[f]) : fields[_];\r\n  },\r\n  filter() {\r\n    error('MultiPulse does not support filtering.');\r\n  },\r\n  materialize() {\r\n    error('MultiPulse does not support materialization.');\r\n  },\r\n  visit(flags, visitor) {\r\n    const p = this,\r\n      pulses = p.pulses,\r\n      n = pulses.length;\r\n    let i = 0;\r\n    if (flags & p.SOURCE) {\r\n      for (; i < n; ++i) {\r\n        pulses[i].visit(flags, visitor);\r\n      }\r\n    } else {\r\n      for (; i < n; ++i) {\r\n        if (pulses[i].stamp === p.stamp) {\r\n          pulses[i].visit(flags, visitor);\r\n        }\r\n      }\r\n    }\r\n    return p;\r\n  }\r\n});\r\n\r\n/* eslint-disable require-atomic-updates */\r\n\r\n/**\r\n * Evaluates the dataflow and returns a Promise that resolves when pulse\r\n * propagation completes. This method will increment the current timestamp\r\n * and process all updated, pulsed and touched operators. When invoked for\r\n * the first time, all registered operators will be processed. This method\r\n * should not be invoked by third-party clients, use {@link runAsync} or\r\n * {@link run} instead.\r\n * @param {string} [encode] - The name of an encoding set to invoke during\r\n *   propagation. This value is added to generated Pulse instances;\r\n *   operators can then respond to (or ignore) this setting as appropriate.\r\n *   This parameter can be used in conjunction with the Encode transform in\r\n *   the vega-encode package.\r\n * @param {function} [prerun] - An optional callback function to invoke\r\n *   immediately before dataflow evaluation commences.\r\n * @param {function} [postrun] - An optional callback function to invoke\r\n *   after dataflow evaluation completes. The callback will be invoked\r\n *   after those registered via {@link runAfter}.\r\n * @return {Promise} - A promise that resolves to this dataflow after\r\n *   evaluation completes.\r\n */\r\nasync function evaluate(encode, prerun, postrun) {\r\n  const df = this,\r\n    async = [];\r\n\r\n  // if the pulse value is set, this is a re-entrant call\r\n  if (df._pulse) return reentrant(df);\r\n\r\n  // wait for pending datasets to load\r\n  if (df._pending) await df._pending;\r\n\r\n  // invoke prerun function, if provided\r\n  if (prerun) await asyncCallback(df, prerun);\r\n\r\n  // exit early if there are no updates\r\n  if (!df._touched.length) {\r\n    df.debug('Dataflow invoked, but nothing to do.');\r\n    return df;\r\n  }\r\n\r\n  // increment timestamp clock\r\n  const stamp = ++df._clock;\r\n\r\n  // set the current pulse\r\n  df._pulse = new Pulse(df, stamp, encode);\r\n\r\n  // initialize priority queue, reset touched operators\r\n  df._touched.forEach(op => df._enqueue(op, true));\r\n  df._touched = UniqueList(id);\r\n  let count = 0,\r\n    op,\r\n    next,\r\n    error;\r\n  try {\r\n    while (df._heap.size() > 0) {\r\n      // dequeue operator with highest priority\r\n      op = df._heap.pop();\r\n\r\n      // re-queue if rank changed\r\n      if (op.rank !== op.qrank) {\r\n        df._enqueue(op, true);\r\n        continue;\r\n      }\r\n\r\n      // otherwise, evaluate the operator\r\n      next = op.run(df._getPulse(op, encode));\r\n      if (next.then) {\r\n        // await if operator returns a promise directly\r\n        next = await next;\r\n      } else if (next.async) {\r\n        // queue parallel asynchronous execution\r\n        async.push(next.async);\r\n        next = StopPropagation;\r\n      }\r\n\r\n      // propagate evaluation, enqueue dependent operators\r\n      if (next !== StopPropagation) {\r\n        if (op._targets) op._targets.forEach(op => df._enqueue(op));\r\n      }\r\n\r\n      // increment visit counter\r\n      ++count;\r\n    }\r\n  } catch (err) {\r\n    df._heap.clear();\r\n    error = err;\r\n  }\r\n\r\n  // reset pulse map\r\n  df._input = {};\r\n  df._pulse = null;\r\n  df.debug(`Pulse ${stamp}: ${count} operators`);\r\n  if (error) {\r\n    df._postrun = [];\r\n    df.error(error);\r\n  }\r\n\r\n  // invoke callbacks queued via runAfter\r\n  if (df._postrun.length) {\r\n    const pr = df._postrun.sort((a, b) => b.priority - a.priority);\r\n    df._postrun = [];\r\n    for (let i = 0; i < pr.length; ++i) {\r\n      await asyncCallback(df, pr[i].callback);\r\n    }\r\n  }\r\n\r\n  // invoke postrun function, if provided\r\n  if (postrun) await asyncCallback(df, postrun);\r\n\r\n  // handle non-blocking asynchronous callbacks\r\n  if (async.length) {\r\n    Promise.all(async).then(cb => df.runAsync(null, () => {\r\n      cb.forEach(f => {\r\n        try {\r\n          f(df);\r\n        } catch (err) {\r\n          df.error(err);\r\n        }\r\n      });\r\n    }));\r\n  }\r\n  return df;\r\n}\r\n\r\n/**\r\n * Queues dataflow evaluation to run once any other queued evaluations have\r\n * completed and returns a Promise that resolves when the queued pulse\r\n * propagation completes. If provided, a callback function will be invoked\r\n * immediately before evaluation commences. This method will ensure a\r\n * separate evaluation is invoked for each time it is called.\r\n * @param {string} [encode] - The name of an encoding set to invoke during\r\n *   propagation. This value is added to generated Pulse instances;\r\n *   operators can then respond to (or ignore) this setting as appropriate.\r\n *   This parameter can be used in conjunction with the Encode transform in\r\n *   the vega-encode package.\r\n * @param {function} [prerun] - An optional callback function to invoke\r\n *   immediately before dataflow evaluation commences.\r\n * @param {function} [postrun] - An optional callback function to invoke\r\n *   after dataflow evaluation completes. The callback will be invoked\r\n *   after those registered via {@link runAfter}.\r\n * @return {Promise} - A promise that resolves to this dataflow after\r\n *   evaluation completes.\r\n */\r\nasync function runAsync(encode, prerun, postrun) {\r\n  // await previously queued functions\r\n  while (this._running) await this._running;\r\n\r\n  // run dataflow, manage running promise\r\n  const clear = () => this._running = null;\r\n  (this._running = this.evaluate(encode, prerun, postrun)).then(clear, clear);\r\n  return this._running;\r\n}\r\n\r\n/**\r\n * Requests dataflow evaluation and the immediately returns this dataflow\r\n * instance. If there are pending data loading or other asynchronous\r\n * operations, the dataflow will evaluate asynchronously after this method\r\n * has been invoked. To track when dataflow evaluation completes, use the\r\n * {@link runAsync} method instead. This method will raise an error if\r\n * invoked while the dataflow is already in the midst of evaluation.\r\n * @param {string} [encode] - The name of an encoding set to invoke during\r\n *   propagation. This value is added to generated Pulse instances;\r\n *   operators can then respond to (or ignore) this setting as appropriate.\r\n *   This parameter can be used in conjunction with the Encode transform in\r\n *   the vega-encode module.\r\n * @param {function} [prerun] - An optional callback function to invoke\r\n *   immediately before dataflow evaluation commences.\r\n * @param {function} [postrun] - An optional callback function to invoke\r\n *   after dataflow evaluation completes. The callback will be invoked\r\n *   after those registered via {@link runAfter}.\r\n * @return {Dataflow} - This dataflow instance.\r\n */\r\nfunction run(encode, prerun, postrun) {\r\n  return this._pulse ? reentrant(this) : (this.evaluate(encode, prerun, postrun), this);\r\n}\r\n\r\n/**\r\n * Schedules a callback function to be invoked after the current pulse\r\n * propagation completes. If no propagation is currently occurring,\r\n * the function is invoked immediately. Callbacks scheduled via runAfter\r\n * are invoked immediately upon completion of the current cycle, before\r\n * any request queued via runAsync. This method is primarily intended for\r\n * internal use. Third-party callers using runAfter to schedule a callback\r\n * that invokes {@link run} or {@link runAsync} should not use this method,\r\n * but instead use {@link runAsync} with prerun or postrun arguments.\r\n * @param {function(Dataflow)} callback - The callback function to run.\r\n *   The callback will be invoked with this Dataflow instance as its\r\n *   sole argument.\r\n * @param {boolean} enqueue - A boolean flag indicating that the\r\n *   callback should be queued up to run after the next propagation\r\n *   cycle, suppressing immediate invocation when propagation is not\r\n *   currently occurring.\r\n * @param {number} [priority] - A priority value used to sort registered\r\n *   callbacks to determine execution order. This argument is intended\r\n *   for internal Vega use only.\r\n */\r\nfunction runAfter(callback, enqueue, priority) {\r\n  if (this._pulse || enqueue) {\r\n    // pulse propagation is currently running, queue to run after\r\n    this._postrun.push({\r\n      priority: priority || 0,\r\n      callback: callback\r\n    });\r\n  } else {\r\n    // pulse propagation already complete, invoke immediately\r\n    try {\r\n      callback(this);\r\n    } catch (err) {\r\n      this.error(err);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Raise an error for re-entrant dataflow evaluation.\r\n */\r\nfunction reentrant(df) {\r\n  df.error('Dataflow already running. Use runAsync() to chain invocations.');\r\n  return df;\r\n}\r\n\r\n/**\r\n * Enqueue an operator into the priority queue for evaluation. The operator\r\n * will be enqueued if it has no registered pulse for the current cycle, or if\r\n * the force argument is true. Upon enqueue, this method also sets the\r\n * operator's qrank to the current rank value.\r\n * @param {Operator} op - The operator to enqueue.\r\n * @param {boolean} [force] - A flag indicating if the operator should be\r\n *   forceably added to the queue, even if it has already been previously\r\n *   enqueued during the current pulse propagation. This is useful when the\r\n *   dataflow graph is dynamically modified and the operator rank changes.\r\n */\r\nfunction enqueue(op, force) {\r\n  const q = op.stamp < this._clock;\r\n  if (q) op.stamp = this._clock;\r\n  if (q || force) {\r\n    op.qrank = op.rank;\r\n    this._heap.push(op);\r\n  }\r\n}\r\n\r\n/**\r\n * Provide a correct pulse for evaluating an operator. If the operator has an\r\n * explicit source operator, we will try to pull the pulse(s) from it.\r\n * If there is an array of source operators, we build a multi-pulse.\r\n * Otherwise, we return a current pulse with correct source data.\r\n * If the pulse is the pulse map has an explicit target set, we use that.\r\n * Else if the pulse on the upstream source operator is current, we use that.\r\n * Else we use the pulse from the pulse map, but copy the source tuple array.\r\n * @param {Operator} op - The operator for which to get an input pulse.\r\n * @param {string} [encode] - An (optional) encoding set name with which to\r\n *   annotate the returned pulse. See {@link run} for more information.\r\n */\r\nfunction getPulse(op, encode) {\r\n  const s = op.source,\r\n    stamp = this._clock;\r\n  return s && isArray(s) ? new MultiPulse(this, stamp, s.map(_ => _.pulse), encode) : this._input[op.id] || singlePulse(this._pulse, s && s.pulse);\r\n}\r\nfunction singlePulse(p, s) {\r\n  if (s && s.stamp === p.stamp) {\r\n    return s;\r\n  }\r\n  p = p.fork();\r\n  if (s && s !== StopPropagation) {\r\n    p.source = s.source;\r\n  }\r\n  return p;\r\n}\r\n\r\nconst NO_OPT = {\r\n  skip: false,\r\n  force: false\r\n};\r\n\r\n/**\r\n * Touches an operator, scheduling it to be evaluated. If invoked outside of\r\n * a pulse propagation, the operator will be evaluated the next time this\r\n * dataflow is run. If invoked in the midst of pulse propagation, the operator\r\n * will be queued for evaluation if and only if the operator has not yet been\r\n * evaluated on the current propagation timestamp.\r\n * @param {Operator} op - The operator to touch.\r\n * @param {object} [options] - Additional options hash.\r\n * @param {boolean} [options.skip] - If true, the operator will\r\n *   be skipped: it will not be evaluated, but its dependents will be.\r\n * @return {Dataflow}\r\n */\r\nfunction touch(op, options) {\r\n  const opt = options || NO_OPT;\r\n  if (this._pulse) {\r\n    // if in midst of propagation, add to priority queue\r\n    this._enqueue(op);\r\n  } else {\r\n    // otherwise, queue for next propagation\r\n    this._touched.add(op);\r\n  }\r\n  if (opt.skip) op.skip(true);\r\n  return this;\r\n}\r\n\r\n/**\r\n * Updates the value of the given operator.\r\n * @param {Operator} op - The operator to update.\r\n * @param {*} value - The value to set.\r\n * @param {object} [options] - Additional options hash.\r\n * @param {boolean} [options.force] - If true, the operator will\r\n *   be re-evaluated even if its value has not changed.\r\n * @param {boolean} [options.skip] - If true, the operator will\r\n *   be skipped: it will not be evaluated, but its dependents will be.\r\n * @return {Dataflow}\r\n */\r\nfunction update(op, value, options) {\r\n  const opt = options || NO_OPT;\r\n  if (op.set(value) || opt.force) {\r\n    this.touch(op, opt);\r\n  }\r\n  return this;\r\n}\r\n\r\n/**\r\n * Pulses an operator with a changeset of tuples. If invoked outside of\r\n * a pulse propagation, the pulse will be applied the next time this\r\n * dataflow is run. If invoked in the midst of pulse propagation, the pulse\r\n * will be added to the set of active pulses and will be applied if and\r\n * only if the target operator has not yet been evaluated on the current\r\n * propagation timestamp.\r\n * @param {Operator} op - The operator to pulse.\r\n * @param {ChangeSet} value - The tuple changeset to apply.\r\n * @param {object} [options] - Additional options hash.\r\n * @param {boolean} [options.skip] - If true, the operator will\r\n *   be skipped: it will not be evaluated, but its dependents will be.\r\n * @return {Dataflow}\r\n */\r\nfunction pulse(op, changeset, options) {\r\n  this.touch(op, options || NO_OPT);\r\n  const p = new Pulse(this, this._clock + (this._pulse ? 0 : 1)),\r\n    t = op.pulse && op.pulse.source || [];\r\n  p.target = op;\r\n  this._input[op.id] = changeset.pulse(p, t);\r\n  return this;\r\n}\r\n\r\nfunction Heap(cmp) {\r\n  let nodes = [];\r\n  return {\r\n    clear: () => nodes = [],\r\n    size: () => nodes.length,\r\n    peek: () => nodes[0],\r\n    push: x => {\r\n      nodes.push(x);\r\n      return siftdown(nodes, 0, nodes.length - 1, cmp);\r\n    },\r\n    pop: () => {\r\n      const last = nodes.pop();\r\n      let item;\r\n      if (nodes.length) {\r\n        item = nodes[0];\r\n        nodes[0] = last;\r\n        siftup(nodes, 0, cmp);\r\n      } else {\r\n        item = last;\r\n      }\r\n      return item;\r\n    }\r\n  };\r\n}\r\nfunction siftdown(array, start, idx, cmp) {\r\n  let parent, pidx;\r\n  const item = array[idx];\r\n  while (idx > start) {\r\n    pidx = idx - 1 >> 1;\r\n    parent = array[pidx];\r\n    if (cmp(item, parent) < 0) {\r\n      array[idx] = parent;\r\n      idx = pidx;\r\n      continue;\r\n    }\r\n    break;\r\n  }\r\n  return array[idx] = item;\r\n}\r\nfunction siftup(array, idx, cmp) {\r\n  const start = idx,\r\n    end = array.length,\r\n    item = array[idx];\r\n  let cidx = (idx << 1) + 1,\r\n    ridx;\r\n  while (cidx < end) {\r\n    ridx = cidx + 1;\r\n    if (ridx < end && cmp(array[cidx], array[ridx]) >= 0) {\r\n      cidx = ridx;\r\n    }\r\n    array[idx] = array[cidx];\r\n    idx = cidx;\r\n    cidx = (idx << 1) + 1;\r\n  }\r\n  array[idx] = item;\r\n  return siftdown(array, start, idx, cmp);\r\n}\r\n\r\n/**\r\n * A dataflow graph for reactive processing of data streams.\r\n * @constructor\r\n */\r\nfunction Dataflow() {\r\n  this.logger(logger());\r\n  this.logLevel(Error);\r\n  this._clock = 0;\r\n  this._rank = 0;\r\n  this._locale = defaultLocale();\r\n  try {\r\n    this._loader = loader();\r\n  } catch (e) {\r\n    // do nothing if loader module is unavailable\r\n  }\r\n  this._touched = UniqueList(id);\r\n  this._input = {};\r\n  this._pulse = null;\r\n  this._heap = Heap((a, b) => a.qrank - b.qrank);\r\n  this._postrun = [];\r\n}\r\nfunction logMethod(method) {\r\n  return function () {\r\n    return this._log[method].apply(this, arguments);\r\n  };\r\n}\r\nDataflow.prototype = {\r\n  /**\r\n   * The current timestamp of this dataflow. This value reflects the\r\n   * timestamp of the previous dataflow run. The dataflow is initialized\r\n   * with a stamp value of 0. The initial run of the dataflow will have\r\n   * a timestap of 1, and so on. This value will match the\r\n   * {@link Pulse.stamp} property.\r\n   * @return {number} - The current timestamp value.\r\n   */\r\n  stamp() {\r\n    return this._clock;\r\n  },\r\n  /**\r\n   * Gets or sets the loader instance to use for data file loading. A\r\n   * loader object must provide a \"load\" method for loading files and a\r\n   * \"sanitize\" method for checking URL/filename validity. Both methods\r\n   * should accept a URI and options hash as arguments, and return a Promise\r\n   * that resolves to the loaded file contents (load) or a hash containing\r\n   * sanitized URI data with the sanitized url assigned to the \"href\" property\r\n   * (sanitize).\r\n   * @param {object} _ - The loader instance to use.\r\n   * @return {object|Dataflow} - If no arguments are provided, returns\r\n   *   the current loader instance. Otherwise returns this Dataflow instance.\r\n   */\r\n  loader(_) {\r\n    if (arguments.length) {\r\n      this._loader = _;\r\n      return this;\r\n    } else {\r\n      return this._loader;\r\n    }\r\n  },\r\n  /**\r\n   * Gets or sets the locale instance to use for formatting and parsing\r\n   * string values. The locale object should be provided by the\r\n   * vega-format library, and include methods such as format, timeFormat,\r\n   * utcFormat, timeParse, and utcParse.\r\n   * @param {object} _ - The locale instance to use.\r\n   * @return {object|Dataflow} - If no arguments are provided, returns\r\n   *   the current locale instance. Otherwise returns this Dataflow instance.\r\n   */\r\n  locale(_) {\r\n    if (arguments.length) {\r\n      this._locale = _;\r\n      return this;\r\n    } else {\r\n      return this._locale;\r\n    }\r\n  },\r\n  /**\r\n   * Get or set the logger instance used to log messages. If no arguments are\r\n   * provided, returns the current logger instance. Otherwise, sets the logger\r\n   * and return this Dataflow instance. Provided loggers must support the full\r\n   * API of logger objects generated by the vega-util logger method. Note that\r\n   * by default the log level of the new logger will be used; use the logLevel\r\n   * method to adjust the log level as needed.\r\n   */\r\n  logger(logger) {\r\n    if (arguments.length) {\r\n      this._log = logger;\r\n      return this;\r\n    } else {\r\n      return this._log;\r\n    }\r\n  },\r\n  /**\r\n   * Logs an error message. By default, logged messages are written to console\r\n   * output. The message will only be logged if the current log level is high\r\n   * enough to permit error messages.\r\n   */\r\n  error: logMethod('error'),\r\n  /**\r\n   * Logs a warning message. By default, logged messages are written to console\r\n   * output. The message will only be logged if the current log level is high\r\n   * enough to permit warning messages.\r\n   */\r\n  warn: logMethod('warn'),\r\n  /**\r\n   * Logs a information message. By default, logged messages are written to\r\n   * console output. The message will only be logged if the current log level is\r\n   * high enough to permit information messages.\r\n   */\r\n  info: logMethod('info'),\r\n  /**\r\n   * Logs a debug message. By default, logged messages are written to console\r\n   * output. The message will only be logged if the current log level is high\r\n   * enough to permit debug messages.\r\n   */\r\n  debug: logMethod('debug'),\r\n  /**\r\n   * Get or set the current log level. If an argument is provided, it\r\n   * will be used as the new log level.\r\n   * @param {number} [level] - Should be one of None, Warn, Info\r\n   * @return {number} - The current log level.\r\n   */\r\n  logLevel: logMethod('level'),\r\n  /**\r\n   * Empty entry threshold for garbage cleaning. Map data structures will\r\n   * perform cleaning once the number of empty entries exceeds this value.\r\n   */\r\n  cleanThreshold: 1e4,\r\n  // OPERATOR REGISTRATION\r\n  add,\r\n  connect,\r\n  rank,\r\n  rerank,\r\n  // OPERATOR UPDATES\r\n  pulse,\r\n  touch,\r\n  update,\r\n  changeset,\r\n  // DATA LOADING\r\n  ingest,\r\n  parse,\r\n  preload,\r\n  request,\r\n  // EVENT HANDLING\r\n  events,\r\n  on,\r\n  // PULSE PROPAGATION\r\n  evaluate,\r\n  run,\r\n  runAsync,\r\n  runAfter,\r\n  _enqueue: enqueue,\r\n  _getPulse: getPulse\r\n};\r\n\r\n/**\r\n * Abstract class for operators that process data tuples.\r\n * Subclasses must provide a {@link transform} method for operator processing.\r\n * @constructor\r\n * @param {*} [init] - The initial value for this operator.\r\n * @param {object} [params] - The parameters for this operator.\r\n * @param {Operator} [source] - The operator from which to receive pulses.\r\n */\r\nfunction Transform(init, params) {\r\n  Operator.call(this, init, null, params);\r\n}\r\ninherits(Transform, Operator, {\r\n  /**\r\n   * Overrides {@link Operator.evaluate} for transform operators.\r\n   * Internally, this method calls {@link evaluate} to perform processing.\r\n   * If {@link evaluate} returns a falsy value, the input pulse is returned.\r\n   * This method should NOT be overridden, instead overrride {@link evaluate}.\r\n   * @param {Pulse} pulse - the current dataflow pulse.\r\n   * @return the output pulse for this operator (or StopPropagation)\r\n   */\r\n  run(pulse) {\r\n    if (pulse.stamp < this.stamp) return pulse.StopPropagation;\r\n    let rv;\r\n    if (this.skip()) {\r\n      this.skip(false);\r\n    } else {\r\n      rv = this.evaluate(pulse);\r\n    }\r\n    rv = rv || pulse;\r\n    if (rv.then) {\r\n      rv = rv.then(_ => this.pulse = _);\r\n    } else if (rv !== pulse.StopPropagation) {\r\n      this.pulse = rv;\r\n    }\r\n    return rv;\r\n  },\r\n  /**\r\n   * Overrides {@link Operator.evaluate} for transform operators.\r\n   * Marshalls parameter values and then invokes {@link transform}.\r\n   * @param {Pulse} pulse - the current dataflow pulse.\r\n   * @return {Pulse} The output pulse (or StopPropagation). A falsy return\r\n       value (including undefined) will let the input pulse pass through.\r\n  */\r\n  evaluate(pulse) {\r\n    const params = this.marshall(pulse.stamp),\r\n      out = this.transform(params, pulse);\r\n    params.clear();\r\n    return out;\r\n  },\r\n  /**\r\n   * Process incoming pulses.\r\n   * Subclasses should override this method to implement transforms.\r\n   * @param {Parameters} _ - The operator parameter values.\r\n   * @param {Pulse} pulse - The current dataflow pulse.\r\n   * @return {Pulse} The output pulse (or StopPropagation). A falsy return\r\n   *   value (including undefined) will let the input pulse pass through.\r\n   */\r\n  transform() {}\r\n});\r\n\r\nconst transforms = {};\r\nfunction definition(type) {\r\n  const t = transform(type);\r\n  return t && t.Definition || null;\r\n}\r\nfunction transform(type) {\r\n  type = type && type.toLowerCase();\r\n  return hasOwnProperty(transforms, type) ? transforms[type] : null;\r\n}\r\n\r\nexport { Dataflow, EventStream, MultiPulse, Operator, Parameters, Pulse, Transform, UniqueList, asyncCallback, changeset, definition, derive, ingest$1 as ingest, isChangeSet, isTuple, rederive, replace, stableCompare, transform, transforms, tupleid };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}